<!doctype html><html lang=zh-cn></html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rails 构建镜像安全处理加密凭证 | icyleaf</title><meta name=keywords content="Rails,Docker"><meta name=description content="Docker 构建镜像该如何正确处理 master key 和 credentials.yml.enc"><meta name=author content="icyleaf"><link rel=canonical href=https://icyleaf.com/2022/09/rails-build-docker-image-handle-encrypted-credentials-securely/><link rel=icon href=https://icyleaf.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://icyleaf.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://icyleaf.com/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://icyleaf.com/android-chrome-192x192.png><link rel=icon type=image/png sizes=512x512 href=https://icyleaf.com/android-chrome-512x512.png><link rel=apple-touch-icon href=https://icyleaf.com/apple-touch-icon.png><link rel=mask-icon href=https://icyleaf.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=https://icyleaf.com/css/main.min.css><link rel=stylesheet href=https://icyleaf.com/font/iconfont.min.css><link rel=stylesheet href=https://icyleaf.com/font-ali/iconfont.min.css><link rel=stylesheet href=https://icyleaf.com/photoswipe/photoswipe.min.css><link rel=canonical href=https://icyleaf.com/2022/09/rails-build-docker-image-handle-encrypted-credentials-securely/><meta property="og:title" content="Rails 构建镜像安全处理加密凭证"><meta property="og:description" content="Docker 构建镜像该如何正确处理 master key 和 credentials.yml.enc"><meta property="og:type" content="article"><meta property="og:url" content="https://icyleaf.com/2022/09/rails-build-docker-image-handle-encrypted-credentials-securely/"><meta property="og:image" content="https://images.unsplash.com/photo-1584949091598-c31daaaa4aa9?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2370&q=80"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-15T13:58:31+08:00"><meta property="article:modified_time" content="2022-09-15T13:58:31+08:00"><meta property="og:see_also" content="https://icyleaf.com/2022/09/perfect-solution-to-steup-rails-encrypted-credentials/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1584949091598-c31daaaa4aa9?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2370&q=80"><meta name=twitter:title content="Rails 构建镜像安全处理加密凭证"><meta name=twitter:description content="Docker 构建镜像该如何正确处理 master key 和 credentials.yml.enc"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://icyleaf.com/posts/"},{"@type":"ListItem","position":2,"name":"Rails 构建镜像安全处理加密凭证","item":"https://icyleaf.com/2022/09/rails-build-docker-image-handle-encrypted-credentials-securely/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rails 构建镜像安全处理加密凭证","name":"Rails 构建镜像安全处理加密凭证","description":"Docker 构建镜像该如何正确处理 master key 和 credentials.yml.enc","keywords":["Rails","Docker"],"articleBody":"最近在做一个小的 Side Project 作为公共服务首要是需要保证用户数据的绝对安全，这就需要对数据库数据做加密处理。\nRails 5.2 开始支持 credentials.yml.enc 加密凭证， 6.0 支持多环境的 credentials 加密凭证， 7.0 支持对 model 数据库表字段加密处理，但我从 5.1 支持 secrets.yml 开始就没使用过。 最近一周开发加摸索下来，总结一句话：一直加密一直爽，容器化奔赴火葬场。\n机制原理 初始化一个 Rails 5.2+ 项目会在项目根目录 config 生成 master.key 和 credentials.yml.enc 两个文件，前者可以理解为核心密钥，后者是用核心密钥通过 ActiveSupport::EncryptedConfiguration 加密类生成的加密后的数据文件。\n只需要保证 master.key 不会泄露，通过 rails credentials:edit 配置服务所需的各自私密 token、secret key 之类也可以安全的提交到 Git 仓库中。\n存储路径 密钥和加密后的文件会存在如下目录：\n1# 缺省 2config/master.key 3config/credentials.yml.enc 4 5# Rails 生产环境决定 (6.0 开始支持) 6# 如下分别对应 development 和 production 环境 7config/credentials/development.key 8config/credentials/development.yml.enc 9 10config/credentials/production.key 11config/credentials/production.yml.enc 触发机制 只要运行的代码会涉及 config/environment.rb 文件解密流程就会自动被触发，比如：\nrails server rails console Rakefile 附加 :environment 参数的所有 tasks 常见加解密报错 解密机制被触发的那一刻，它会从存储路径从缺省到当前生产环境去寻找对应的文件，master key 会优先读取 RAILS_MASTER_KEY 环境变量的值，没有才会去存储文件读取，都没有找到就报错 MissingKeyError 错误。\nmaster key 在 Rails 5.2 ~ 7 版本密钥的长度必须符合 aes-128-gcm 也就是 32 字节，设置错误会得到 InvalidKeyLengthError 错误。\n*.enc 文件不存在会触发 MissingContentError 错误。\n其他的错误还有可能是：\n1# 通常是 credentials.yml.enc 文件缺失或未设置 secret_key_base (SECRET_KEY_BASE) 的值 2ArgumentError: Missing `secret_key_base` for 'production' environment, set this string with `bin/rails credentials:edit` 3 4# master key 密钥不正确无法解密 5Unable to load application: ActiveSupport::MessageEncryptor::InvalidMessage: ActiveSupport::MessageEncryptor::InvalidMessage 6 7# 错误同上 8OpenSSL::Cipher::CipherError 成就大体都列出来了，至于你能到哪步就看你的造化了（开玩笑）。\n数据库字段加密 Rails 默认并不会对数据库字段加密，在 7.0 开始允许开发者定义加密字段也允许自定义加解密方法。这个不是本文的讨论范围不再展开。\n初始化需要通过如下命令生成一个随机的 Keys：\n1$ rails db:encryption:init 2Add this entry to the credentials of the target environment: 3 4active_record_encryption: 5 primary_key: KMw07GoiPScVwtmoNxlBv7YibFCnB4dU 6 deterministic_key: CTttlez04KZcy3MCMFtZ8FUEopSAmJOr 7 key_derivation_salt: FwUgrDWHX3wN7kKw5gYSsYEgzxRnYBWh 在通过 rails credentials:edit 把上端加密串加到 credentials 里面保存即可，不同的加密串是无法解密已经存在数据库中的数据的，切记！切记！切记！ 否则你会再获得一个成就 ActiveRecord::Encryption::Errors::Decryption 报错。\n镜像构建处理 恭喜你，从现在开始你本应当直面恐惧，可惜你发现了我这篇文章缺少了点悲惨的经历。\n制作 Docker 镜像无论什么情况都要保证不会包含任何私密数据，Rails 绕不开的点主要是 rails assets:complie。 上面我也说了只要涉及 :environment 参数的所有 tasks 都会走解密流程，它也不例外。\n构建方面我通过三种方式来解析如果从不安全到安全的构建过程：\n🚫 最不安全的方式 镜像构建允许设置 build-arg 传递：\n1FROM ruby:3.0.3 2 3ARG master_key 4ENV RAILS_MASTER_KEY=$master_key 5ENV RAILS_ENV=production 6 7# 省略 8... 9 10RUN bin/rails assets:complie 11# 或者 12RUN RAILS_MASTER_KEY=$master_key bin/rails assets:complie 执行构建命令 docker build -t app --build-arg master_key=[32bits-length-key] . 构建后虽然可以获得镜像，但构建时设置的值也被封装在了容器中，就算没有封装到容器中使用 docker history 也可以看到，因此这种方式是绝对不可取的。\n⭕️ 改进版 你可能会看到有些镜像的 Dockerfile 里面会包含多个 FROM 的多阶段构建。这个是为了利用隔离资源，重复利用缓存机制的方式使得最终的容器极可能的小和安全。我们可以利用它把私密数据隔离在前面的临时镜像中。\n1FROM ruby:3.0.3 as builder 2 3ARG workspace=/app 4ARG master_key 5ENV RAILS_MASTER_KEY=$master_key 6ENV RAILS_ENV=production 7 8# 省略 9... 10 11WORKDIR $workspace 12RUN bin/rails assets:complie 13 14# 省略 15... 16 17FROM ruby:3.0.3-slim 18 19# 省略 20... 21 22COPY --from=builder $workspace $workspace 镜像存在 builder 和一个缺省名字（通常是 stage-N, N 是数字从 1 开始）两个阶段，第一阶段是最不安全方式的实现方式，这里在最后一个阶段通过一个干净安全的镜像把上一个阶段的结果文件复制过来就达成了第一个阶段中私密数据泄露的问题。\n这种方式也是当前大多数人会应用的方式，尤其利用 Github Action 的 Encrypted secrets 功能从某种程度上杜绝了隐私数据的泄露。\n✅ 加强版 Buildkit 是 Docker 新一代镜像构建工具，启用可以通过配置环境变量 DOCKER_BUILDKIT=1 或在 Docker 配置文件的 features 字典增加 \"buildkit\" : \"true\"。\n由于采用新的构建工具，额外还需要在 Dockerfile 头部显性声明新的语法：syntax = docker/dockerfile:1.2 配合 新的构建 secret 1# syntax = docker/dockerfile:1.2 2FROM ruby:3.0.3 3 4ARG workspace=/app 5WORKDIR $workspace 6 7# 省略 8... 9 10RUN --mount=type=secret,id=master_key,target=config/master.key,required=true \\ 11 bin/rails assets:precompile 构建命令执行需要通过 buildx CLI 子命令来完成：\n1$ docker buildx build \\ 2 --secret id=master_key,src=config/master.key \\ 3 -t app . 结合 –mount-type=secret 支持的参数:\n参数名 说明 id 密钥的唯一 id，默认是 target 参数的值的文件名 target 镜像内挂载的路径，默认是 /run/secrets/ + id required 设置 true 当密钥不存在时报错，默认是 false mode 挂载后的文件权限，默认是 0400 uid 设置密钥文件的用户 ID，默认是 0 gid 设置密钥文件的用户组 ID，默认是 0 id 关联 CLI 传参和构建镜像中执行步骤，CLI 入参设置 secret 的输入文件，构建镜像则需要把 secret 导出到镜像中具体的路径，其实就是这么简单。极少数支持 Docker 部署的云服务，比如 Render 支持这种方式。部署到云服务上还需要重新考量下。\n本篇小结 折腾一圈终于获得了一个干净、安全的镜像，等到部署时又傻眼了。面向技术人员或公司的项目倒还好，初始化时通过命令一通操作配置完也不需要处理 master key 不匹配的情况。 无论使用上面改进版还是加强版都能过顺利跑起来。如果 Docker 镜像是要面向客户的话，怎么让他们初始化一个属于他们自己的 master key 和加密数据呢？开始挠头了吧。\n未完待续… 翻看答案。\n参考资源 Railsのcredentials.yml.encとmaster keyをDockerで安全に扱う Don’t leak your Docker image’s build secrets ","wordCount":"1968","inLanguage":"zh-cn","image":"https://images.unsplash.com/photo-1584949091598-c31daaaa4aa9?ixlib=rb-1.2.1\u0026ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026auto=format\u0026fit=crop\u0026w=2370\u0026q=80","datePublished":"2022-09-15T13:58:31+08:00","dateModified":"2022-09-15T13:58:31+08:00","author":{"@type":"Person","name":"icyleaf"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://icyleaf.com/2022/09/rails-build-docker-image-handle-encrypted-credentials-securely/"},"publisher":{"@type":"Organization","name":"icyleaf","logo":{"@type":"ImageObject","url":"https://icyleaf.com/favicon.ico"}}}</script></head><body><div class=wrapper><nav class=navbar><progress class=content_progress max=0 value=0></progress><div class=container><div class="navbar-header header-logo"><a href=https://icyleaf.com/>icyleaf</a></div><div class=navbar-right><span class=menu><a class=menu-item href=https://icyleaf.com/series/homelab title>homelab 系列</a>
<a class=menu-item href=https://icyleaf.com/projects title>开源项目</a>
<a class=menu-item href=https://icyleaf.com/gears title>我的设备</a>
<a class=menu-item href=https://icyleaf.com/about title>关于</a>
<span class=divide></span>
<a href=javascript:void(0); class=theme-switch><i class="iconfont icon-dark-mode"></i></a></span></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><progress class=content_progress max=0 value=0></progress><div class=container><div class=navbar><div class="navbar-header header-logo"><a href=https://icyleaf.com/>icyleaf</a></div><div class=navbar-right><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-dark-mode"></i></a></div><div class=menu-toggle><span></span><span></span><span></span></div></div></div><div class=menu id=mobile-menu><nav class=mb-md><a class=menu-item href=https://icyleaf.com/series/homelab title><h3>homelab 系列</h3><div class=menu-active></div></a><a class=menu-item href=https://icyleaf.com/projects title><h3>开源项目</h3><div class=menu-active></div></a><a class=menu-item href=https://icyleaf.com/gears title><h3>我的设备</h3><div class=menu-active></div></a><a class=menu-item href=https://icyleaf.com/about title><h3>关于</h3><div class=menu-active></div></a></nav></div></div></nav><main class=main><div class=post-cover><img src="https://images.unsplash.com/photo-1584949091598-c31daaaa4aa9?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=2370&amp;q=80" loading=lazy><p class=cover-author>Photo by
<a href=https://unsplash.com/photos/FWoq_ldWlNQ>Mitchell Luo</a>
/
<a href=https://unsplash.com>Unsplash</a></p></div><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop=description>Rails 构建镜像安全处理加密凭证</h1><div class=post-description>Docker 构建镜像该如何正确处理 master key 和 credentials.yml.enc</div><div class=post-meta><time datetime=2022-09-15 itemprop=datePublished>2022-09-15</time>
·
<span class=tags>Rails, Docker</span>
·
<span class=post-word-count>1968 words · 8 minutes</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>目录</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><a href=#机制原理>机制原理</a><ul><li><a href=#存储路径>存储路径</a></li><li><a href=#触发机制>触发机制</a></li><li><a href=#常见加解密报错>常见加解密报错</a></li></ul></li><li><a href=#数据库字段加密>数据库字段加密</a></li><li><a href=#镜像构建处理>镜像构建处理</a><ul><li><a href=#-最不安全的方式>🚫 最不安全的方式</a></li><li><a href=#-改进版>⭕️ 改进版</a></li><li><a href=#-加强版>✅ 加强版</a></li></ul></li><li><a href=#本篇小结>本篇小结</a></li><li><a href=#参考资源>参考资源</a></li></ul></nav></div></div><div class=post-content><div class=post-series><h4 class=series-title><a href=https://icyleaf.com/series/dockerdeployrails/>Docker 部署 Rails 指北（2 篇）</a></h4><ol class=series-list><li class=series-item><span class=current-serie>Rails 构建镜像安全处理加密凭证</span></li><li class=series-item><a href=https://icyleaf.com/2022/09/perfect-solution-to-steup-rails-encrypted-credentials/>Rails 产品环境配置加密凭证的完美方案</a></li></ol></div><div id=post-gallery><p>最近在做一个小的 Side Project 作为公共服务首要是需要保证用户数据的绝对安全，这就需要对数据库数据做加密处理。</p><p>Rails <a href=https://qiita.com/NaokiIshimura/items/2a179f2ab910992c4d39>5.2</a> 开始支持 <code>credentials.yml.enc</code> 加密凭证，
<a href=https://blog.saeloun.com/2019/10/10/rails-6-adds-support-for-multi-environment-credentials.html>6.0</a> 支持多环境的 credentials 加密凭证，
<a href=https://blog.saeloun.com/2021/06/09/rails-7-add-encryption-to-active-record.html>7.0</a> 支持对 model 数据库表字段加密处理，但我从 5.1 支持 <code>secrets.yml</code> 开始就没使用过。
最近一周开发加摸索下来，总结一句话：<strong>一直加密一直爽，容器化奔赴火葬场。</strong></p><h2 id=机制原理>机制原理</h2><p>初始化一个 Rails 5.2+ 项目会在项目根目录 <code>config</code> 生成 <code>master.key</code> 和 <code>credentials.yml.enc</code> 两个文件，前者可以理解为核心密钥，后者是用核心密钥通过
<a href=https://github.com/rails/rails/blob/7-0-stable/activesupport/lib/active_support/encrypted_configuration.rb>ActiveSupport::EncryptedConfiguration</a> 加密类生成的加密后的数据文件。</p><p>只需要保证 <code>master.key</code> 不会泄露，通过 <code>rails credentials:edit</code> 配置服务所需的各自私密 token、secret key 之类也可以安全的提交到 Git 仓库中。</p><h3 id=存储路径>存储路径</h3><p>密钥和加密后的文件会存在如下目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln> 1</span><span class=cl><span class=c1># 缺省</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>config/master.key
</span></span><span class=line><span class=ln> 3</span><span class=cl>config/credentials.yml.enc
</span></span><span class=line><span class=ln> 4</span><span class=cl>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=c1># Rails 生产环境决定 (6.0 开始支持)</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl><span class=c1># 如下分别对应 development 和 production 环境</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>config/credentials/development.key
</span></span><span class=line><span class=ln> 8</span><span class=cl>config/credentials/development.yml.enc
</span></span><span class=line><span class=ln> 9</span><span class=cl>
</span></span><span class=line><span class=ln>10</span><span class=cl>config/credentials/production.key
</span></span><span class=line><span class=ln>11</span><span class=cl>config/credentials/production.yml.enc
</span></span></code></pre></div><h3 id=触发机制>触发机制</h3><p>只要运行的代码会涉及 <code>config/environment.rb</code> 文件解密流程就会自动被触发，比如：</p><ul><li><code>rails server</code></li><li><code>rails console</code></li><li><code>Rakefile</code> 附加 <code>:environment</code> 参数的所有 tasks</li></ul><h3 id=常见加解密报错>常见加解密报错</h3><p>解密机制被触发的那一刻，它会从存储路径从缺省到当前生产环境去寻找对应的文件，master key 会优先读取 <code>RAILS_MASTER_KEY</code> 环境变量的值，没有才会去存储文件读取，都没有找到就报错 <code>MissingKeyError</code> 错误。</p><p>master key 在 Rails 5.2 ~ 7 版本密钥的长度必须符合 aes-128-gcm 也就是 32 字节，设置错误会得到 <code>InvalidKeyLengthError</code> 错误。</p><p><code>*.enc</code> 文件不存在会触发 <code>MissingContentError</code> 错误。</p><p>其他的错误还有可能是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln>1</span><span class=cl><span class=c1># 通常是 credentials.yml.enc 文件缺失或未设置 secret_key_base (SECRET_KEY_BASE) 的值</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>ArgumentError: Missing <span class=sb>`</span>secret_key_base<span class=sb>`</span> <span class=k>for</span> <span class=s1>&#39;production&#39;</span> environment, <span class=nb>set</span> this string with <span class=sb>`</span>bin/rails credentials:edit<span class=sb>`</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=c1># master key 密钥不正确无法解密</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>Unable to load application: ActiveSupport::MessageEncryptor::InvalidMessage: ActiveSupport::MessageEncryptor::InvalidMessage
</span></span><span class=line><span class=ln>6</span><span class=cl>
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=c1># 错误同上</span>
</span></span><span class=line><span class=ln>8</span><span class=cl>OpenSSL::Cipher::CipherError
</span></span></code></pre></div><p>成就大体都列出来了，至于你能到哪步就看你的造化了（开玩笑）。</p><h2 id=数据库字段加密>数据库字段加密</h2><p>Rails 默认并不会对数据库字段加密，在 7.0 开始允许开发者定义加密字段也允许自定义加解密方法。这个不是本文的讨论范围不再展开。</p><p>初始化需要通过如下命令生成一个随机的 Keys：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln>1</span><span class=cl>$ rails db:encryption:init
</span></span><span class=line><span class=ln>2</span><span class=cl>Add this entry to the credentials of the target environment:
</span></span><span class=line><span class=ln>3</span><span class=cl>
</span></span><span class=line><span class=ln>4</span><span class=cl>active_record_encryption:
</span></span><span class=line><span class=ln>5</span><span class=cl>  primary_key: KMw07GoiPScVwtmoNxlBv7YibFCnB4dU
</span></span><span class=line><span class=ln>6</span><span class=cl>  deterministic_key: CTttlez04KZcy3MCMFtZ8FUEopSAmJOr
</span></span><span class=line><span class=ln>7</span><span class=cl>  key_derivation_salt: FwUgrDWHX3wN7kKw5gYSsYEgzxRnYBWh
</span></span></code></pre></div><p>在通过 <code>rails credentials:edit</code> 把上端加密串加到 credentials 里面保存即可，<strong>不同的加密串是无法解密已经存在数据库中的数据的，切记！切记！切记！</strong>
否则你会再获得一个成就 <code>ActiveRecord::Encryption::Errors::Decryption</code> 报错。</p><h2 id=镜像构建处理>镜像构建处理</h2><blockquote><p>恭喜你，从现在开始你本应当直面恐惧，可惜你发现了我这篇文章缺少了点悲惨的经历。</p></blockquote><p>制作 Docker 镜像无论什么情况都要保证不会包含任何私密数据，Rails 绕不开的点主要是 <code>rails assets:complie</code>。
上面我也说了只要涉及 <code>:environment</code> 参数的所有 tasks 都会走解密流程，它也不例外。</p><p>构建方面我通过三种方式来解析如果从不安全到安全的构建过程：</p><h3 id=-最不安全的方式>🚫 最不安全的方式</h3><p>镜像构建允许设置 <a href=https://docs.docker.com/engine/reference/commandline/build/#set-build-time-variables---build-arg>build-arg</a> 传递：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=ln> 1</span><span class=cl><span class=k>FROM</span><span class=s> ruby:3.0.3</span><span class=err>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=err></span><span class=k>ARG</span> master_key<span class=err>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>RAILS_MASTER_KEY</span><span class=o>=</span><span class=nv>$master_key</span><span class=err>
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>RAILS_ENV</span><span class=o>=</span>production
</span></span><span class=line><span class=ln> 6</span><span class=cl>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=c># 省略</span><span class=err>
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=err></span>...<span class=err>
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=err></span><span class=k>RUN</span> bin/rails assets:complie<span class=err>
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=err></span><span class=c># 或者</span><span class=err>
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nv>RAILS_MASTER_KEY</span><span class=o>=</span><span class=nv>$master_key</span> bin/rails assets:complie<span class=err>
</span></span></span></code></pre></div><p>执行构建命令 <code>docker build -t app --build-arg master_key=[32bits-length-key] .</code> 构建后虽然可以获得镜像，但构建时设置的值也被封装在了容器中，就算没有封装到容器中使用 <code>docker history</code> 也可以看到，因此这种方式是绝对不可取的。</p><h3 id=-改进版>⭕️ 改进版</h3><p>你可能会看到有些镜像的 Dockerfile 里面会包含多个 <code>FROM</code> 的<a href=https://docs.docker.com/develop/develop-images/multistage-build/>多阶段构建</a>。这个是为了利用隔离资源，重复利用缓存机制的方式使得最终的容器极可能的小和安全。我们可以利用它把私密数据隔离在前面的临时镜像中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=ln> 1</span><span class=cl><span class=k>FROM</span><span class=s> ruby:3.0.3 as builder</span><span class=err>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>workspace</span><span class=o>=</span>/app<span class=err>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=err></span><span class=k>ARG</span> master_key<span class=err>
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>RAILS_MASTER_KEY</span><span class=o>=</span><span class=nv>$master_key</span><span class=err>
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=err></span><span class=k>ENV</span> <span class=nv>RAILS_ENV</span><span class=o>=</span>production
</span></span><span class=line><span class=ln> 7</span><span class=cl>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=c># 省略</span><span class=err>
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=err></span>...<span class=err>
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> $workspace</span><span class=err>
</span></span></span><span class=line><span class=ln>12</span><span class=cl><span class=err></span><span class=k>RUN</span> bin/rails assets:complie<span class=err>
</span></span></span><span class=line><span class=ln>13</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln>14</span><span class=cl><span class=err></span><span class=c># 省略</span><span class=err>
</span></span></span><span class=line><span class=ln>15</span><span class=cl><span class=err></span>...<span class=err>
</span></span></span><span class=line><span class=ln>16</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> ruby:3.0.3-slim</span><span class=err>
</span></span></span><span class=line><span class=ln>18</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln>19</span><span class=cl><span class=err></span><span class=c># 省略</span><span class=err>
</span></span></span><span class=line><span class=ln>20</span><span class=cl><span class=err></span>...<span class=err>
</span></span></span><span class=line><span class=ln>21</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln>22</span><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span>builder <span class=nv>$workspace</span> <span class=nv>$workspace</span><span class=err>
</span></span></span></code></pre></div><p>镜像存在 <code>builder</code> 和一个缺省名字（通常是 <code>stage-N</code>, N 是数字从 1 开始）两个阶段，第一阶段是最不安全方式的实现方式，这里在最后一个阶段通过一个干净安全的镜像把上一个阶段的结果文件复制过来就达成了第一个阶段中私密数据泄露的问题。</p><p>这种方式也是当前大多数人会应用的方式，尤其利用 Github Action 的 <a href=https://docs.github.com/en/actions/security-guides/encrypted-secrets>Encrypted secrets</a> 功能从某种程度上杜绝了隐私数据的泄露。</p><h3 id=-加强版>✅ 加强版</h3><p><a href=https://docs.docker.com/develop/develop-images/build_enhancements/>Buildkit</a> 是 Docker 新一代镜像构建工具，启用可以通过配置环境变量 <code>DOCKER_BUILDKIT=1</code> 或在 Docker 配置文件的 features 字典增加 <code>"buildkit" : "true"</code>。</p><p>由于采用新的构建工具，额外还需要在 Dockerfile 头部显性声明新的语法：<code>syntax = docker/dockerfile:1.2</code> 配合
<a href=https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information>新的构建 secret</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=ln> 1</span><span class=cl><span class=c># syntax = docker/dockerfile:1.2</span><span class=err>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> ruby:3.0.3</span><span class=err>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>workspace</span><span class=o>=</span>/app<span class=err>
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> $workspace</span><span class=err>
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=err></span><span class=c># 省略</span><span class=err>
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=err></span>...<span class=err>
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=err>
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=err></span><span class=k>RUN</span> --mount<span class=o>=</span><span class=nv>type</span><span class=o>=</span>secret,id<span class=o>=</span>master_key,target<span class=o>=</span>config/master.key,required<span class=o>=</span><span class=nb>true</span> <span class=se>\
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=se></span>    bin/rails assets:precompile<span class=err>
</span></span></span></code></pre></div><p>构建命令执行需要通过 <a href=https://docs.docker.com/build/buildx/install/>buildx</a> CLI 子命令来完成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=ln>1</span><span class=cl>$ docker buildx build <span class=se>\
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=se></span>  --secret <span class=nv>id</span><span class=o>=</span>master_key,src<span class=o>=</span>config/master.key <span class=se>\
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=se></span>  -t app .
</span></span></code></pre></div><p>结合 <a href=https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/reference.md#run---mounttypesecret>&ndash;mount-type=secret</a> 支持的参数:</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>密钥的唯一 id，默认是 target 参数的值的文件名</td></tr><tr><td>target</td><td>镜像内挂载的路径，默认是 <code>/run/secrets/</code> + <code>id</code></td></tr><tr><td>required</td><td>设置 <code>true</code> 当密钥不存在时报错，默认是 <code>false</code></td></tr><tr><td>mode</td><td>挂载后的文件权限，默认是 <code>0400</code></td></tr><tr><td>uid</td><td>设置密钥文件的用户 ID，默认是 <code>0</code></td></tr><tr><td>gid</td><td>设置密钥文件的用户组 ID，默认是 <code>0</code></td></tr></tbody></table><p><code>id</code> 关联 CLI 传参和构建镜像中执行步骤，CLI 入参设置 secret 的输入文件，构建镜像则需要把 secret 导出到镜像中具体的路径，其实就是这么简单。极少数支持 Docker
部署的云服务，比如 <a href=https://render.com/docs/docker-secrets>Render</a> 支持这种方式。部署到云服务上还需要重新考量下。</p><h2 id=本篇小结>本篇小结</h2><p>折腾一圈终于获得了一个干净、安全的镜像，等到部署时又傻眼了。面向技术人员或公司的项目倒还好，初始化时通过命令一通操作配置完也不需要处理 master key 不匹配的情况。
无论使用上面改进版还是加强版都能过顺利跑起来。如果 Docker 镜像是要面向客户的话，怎么让他们初始化一个属于他们自己的 master key 和加密数据呢？开始挠头了吧。</p><p><del>未完待续&mldr;</del> <a href=https://icyleaf.com/2022/09/perfect-solution-to-steup-rails-encrypted-credentials/>翻看答案</a>。</p><h2 id=参考资源>参考资源</h2><ul><li><a href=https://techblog.lclco.com/entry/2021/07/27/110000>Railsのcredentials.yml.encとmaster keyをDockerで安全に扱う</a></li><li><a href=https://pythonspeed.com/articles/docker-build-secrets/>Don’t leak your Docker image’s build secrets</a></li></ul><div class=post-donate><p class=post-donate-title>如果你觉得我的文章对你有帮助，欢迎打赏，这对我非常重要，谢谢！</p><div class=post-donate-channel><img src=https://icyleaf.com/images/donate/alipay.png alt=支付宝打赏>
<img src=https://icyleaf.com/images/donate/wechat.png alt=微信打赏></div></div></div></div><div class=post-nav><a href=https://icyleaf.com/2022/02/how-to-homelab-part-0/ class=prev rel=prev title="如何搭建家用 homelab: 先导篇"><i class="iconfont icon-left"></i>&nbsp;如何搭建家用 homelab: 先导篇</a>
<a href=https://icyleaf.com/2022/09/perfect-solution-to-steup-rails-encrypted-credentials/ class=next rel=next title="Rails 产品环境配置加密凭证的完美方案">Rails 产品环境配置加密凭证的完美方案&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><script>var getTheme=window.localStorage&&window.localStorage.getItem("blog-dark-mode"),getTheme=getTheme??"github-light";let theme=getTheme==="dark"?"github-dark":"github-light",s=document.createElement("script");s.src="https://utteranc.es/client.js",s.setAttribute("repo","icyleaf/icyleaf.com"),s.setAttribute("issue-term","pathname"),s.setAttribute("theme",theme),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.post-comment").innerHTML="",document.querySelector("div.post-comment").appendChild(s)</script></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2005 - 2024</span>
<span>🍺</span>
<span class=author itemprop=copyrightHolder><a href=https://icyleaf.com/>icyleaf</a></span></div></footer><script defer src=https://fastly.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.min.js crossorigin=anonymous></script><script defer src=https://icyleaf.com/js/vendor_main.min.js></script>
<script type=module>
  
  import PhotoSwipeLightbox from '\/photoswipe\/photoswipe-lightbox.esm.js';

  const lightbox = new PhotoSwipeLightbox({
    gallery: '#post-gallery',
    children: 'a.gallery-item',
    pswpModule: () => import('\/photoswipe\/photoswipe.esm.js'),
  });
  lightbox.init();
</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TKQBZ7R259"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TKQBZ7R259")</script></div></body></html>