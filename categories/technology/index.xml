<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technology on icyleaf</title>
    <link>http://icyleaf.com/categories/technology/index.xml</link>
    <description>Recent content in Technology on icyleaf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2007</copyright>
    <atom:link href="http://icyleaf.com/categories/technology/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>攒了一台 4K 视频剪辑黑苹果</title>
      <link>http://icyleaf.com/2019/01/itx-coffee-lake-hackintosh-build-for-4k-video-editing</link>
      <pubDate>Wed, 30 Jan 2019 10:30:12 +0000</pubDate>
      
      <guid>http://icyleaf.com/2019/01/itx-coffee-lake-hackintosh-build-for-4k-video-editing</guid>
      <description>

&lt;h2 id=&#34;装机清单&#34;&gt;装机清单&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;台式机借鉴国外 $1000k 攒机思路在不考虑显示器预算为 6000 元人民币。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;品牌型号&lt;/th&gt;
&lt;th&gt;价格&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;Intel i7 9700k&lt;/td&gt;
&lt;td&gt;2550&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;主板&lt;/td&gt;
&lt;td&gt;华擎 Z390 Phantom Gaming itx/ac&lt;/td&gt;
&lt;td&gt;1399&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;散热器&lt;/td&gt;
&lt;td&gt;九州风神 船长 240 EX White RGB&lt;/td&gt;
&lt;td&gt;453&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;海盗船 Vengeance LPX DDR4 3000 16G x 1&lt;/td&gt;
&lt;td&gt;719&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SSD&lt;/td&gt;
&lt;td&gt;三星 970 EVO 250G&lt;/td&gt;
&lt;td&gt;489&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;机箱&lt;/td&gt;
&lt;td&gt;追风者 215P ITX 侧透 RGB&lt;/td&gt;
&lt;td&gt;489&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;电源&lt;/td&gt;
&lt;td&gt;讯景 XTR550&lt;/td&gt;
&lt;td&gt;354&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;显卡&lt;/td&gt;
&lt;td&gt;RX560~580&lt;/td&gt;
&lt;td&gt;预算超了暂时没有采购&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;无线网卡/蓝牙&lt;/td&gt;
&lt;td&gt;博通 BCM943602CS&lt;/td&gt;
&lt;td&gt;临近春节没有买到&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;显示器&lt;/td&gt;
&lt;td&gt;LG 27UL600 4k HDR400 IPS&lt;/td&gt;
&lt;td&gt;单独预算&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;总价&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;为什么要台式机&#34;&gt;为什么要台式机？&lt;/h3&gt;

&lt;p&gt;堂堂一个长期苹果用户的码农咋想起来要组装台式机了？这个计划其实我已经盘算好久好久，要不是库克这两年的出价策略我还真把这个念头打消了。 对于现在入一台能用好几年的 Mac 设备基本上都是要顶配了，价格能又不忍直视。&lt;/p&gt;

&lt;p&gt;以我现有几台笔记本为例，只有内存和硬盘可更换的加持下 MBP 2011 Late 低配我现在拿来用 VSCode 写代码跑服务也没啥太大问题。而手里的 MBP 2013 Mid 低配因为内存和硬盘全焊丝经常性内存不足卡死，硬盘不足，就连我老婆都恨不得把它扔了，主力机器 MBP 2015 Mid 中配后期更换 SSD 又可以再战 3 年。&lt;/p&gt;

&lt;p&gt;当我说要组装台式机的时候不少朋友反问现在还需要用台式机吗，虽然我嘴上只是说说攒着玩啊，现在外出基本上手机可以满足要求，带着笔记本其实也就是存下照片（是的我知道有种东西叫数码伴侣），其实我就是想要一台可配置的机器，不乏有这样想法的开发者，这也是为什么 MacBook Pro（后面简称 MBP）2015 版本的二手机器畅销的原因。&lt;/p&gt;

&lt;p&gt;以上的配置因为预算上限没买独立显卡和无线网卡/蓝牙的情况下总花费正好 6000 元整一分不多一分不少让我自己都特别吃惊（显示器是后批的预算），购买渠道主要是哪里便宜去哪里，大部分淘宝，极个别京东（比如有漏液风险度水冷）。其性价比完爆 2018 年新换代的 Mac mini（不考虑体积和接口种类），加上显示器虽然比不上 5k iMac 但其他方面可不差，再加上攒机配置基本上属于顶配（虽然没上 9900k）除了内存以外都不是瓶颈。&lt;/p&gt;

&lt;h3 id=&#34;为什么要视频剪辑&#34;&gt;为什么要视频剪辑？&lt;/h3&gt;

&lt;p&gt;业余兴趣爱好一直没有行动。之前出去玩攒了不少的视频素材，只有在结婚前花了三个月用 iMovie 剪了一个婚礼上播放的&lt;a href=&#34;https://v.youku.com/v_show/id_XOTQyNTg0ODA4.html?sharefrom=iphone&amp;amp;sharekey=9aa274d71e8a3ba95e2fcf03efbc9e8e0&#34;&gt;视频&lt;/a&gt;之后也有想学 Final Cut Pro（简称 FCP） 主要还是因为硬件不达标搁浅。&lt;/p&gt;

&lt;p&gt;题外话，经过慎重考虑我选择了 Adobe Premiere，支持 Windows 和 macOS 系统而且它也支持和 FCP 一样对独立显卡的渲染优化，反正这俩 App 对我来说都是新的。&lt;/p&gt;

&lt;h3 id=&#34;为什么黑苹果&#34;&gt;为什么黑苹果？&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;请不要鄙视和职责用黑苹果的用户，现在 macOS 系统已经是免费安装也都是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Vanilla_software&#34;&gt;Vanilla&lt;/a&gt; 方式。安装黑苹果尤其是自己动手这也是符合黑客精神。我认为自己来安装黑苹果是一种充满冒险和兴奋的事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;兼容黑苹果也是选择硬件的很重要的指标之一，虽然我会安装 Windows 系统，长期我更倾向于 macOS 系统。这也是一个长期 Mac 用户最舒服的使用方式，减少各方面的迁移成本，听说某大厂的游戏部门程序员全部采用黑苹果方案。&lt;/p&gt;

&lt;h3 id=&#34;为什么选择-intel-9700k&#34;&gt;为什么选择 Intel 9700k？&lt;/h3&gt;

&lt;p&gt;本来是要买 8 代 8700k 的，我买的时候（2019年初）8700k 价格溢价太高！稍微加点钱就能上 9 代 9700k 了！尽管市面上的 Mac 主机还都没有 9 代或许今年内应该能够发售再加上 tonymacx86 已经有很多 9 代的成功案例，何乐而不为呢，大不了在 Apple 在支持 9 代之前我先用 Windows 嘛。&lt;/p&gt;

&lt;p&gt;为什么要带 &lt;code&gt;k&lt;/code&gt;？可以超频啊！目前默频的情况基本满足，后面无论是视频剪辑还是玩游戏的话可以适当超频，配合华擎主板只要 CPU 不踩雷轻松上 5Ghz。 当然还是要考虑黑苹果的兼容性 AMD 在这方面真 YES 不起来。&lt;/p&gt;

&lt;h3 id=&#34;为什么主板选择华擎-z390&#34;&gt;为什么主板选择华擎 Z390？&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;CPU 都上 9700k 了。为什么主板还要限制在 Z370 平台（虽然 9 代兼容），直接上 Z390 啊！价格也合适！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;都说技嘉是黑苹果首选的主板，其次是华硕、微星一二线大厂，一说起华擎可能在十几年前可能都没听过这个牌子（比如我，毕竟十几年没在台式机混过了）或者是华擎出妖板，这些确实没错。&lt;/p&gt;

&lt;p&gt;我选择华擎的主板主要有三大原因：第一在 Z390 系列里面它足够便宜（价格屠夫），第二是主板供电相对可靠且硬件种类非常强大（残血雷电口除外），第三在 hackintosher 看到 &lt;a href=&#34;https://hackintosher.com/blog/best-motherboard-brand-hackintoshing-2017-kabylake/&#34;&gt;2017 年评出的最佳黑苹果主板&lt;/a&gt;第一名就是华擎，原因是该主板很容易找到解决方案，还能够很好的支持睡眠唤醒。最近在 tonymacx86 华擎主板成功的案例也非常多。如果非要说缺点就是 BIOS 功能太弱版本更新不太稳定。&lt;/p&gt;

&lt;p&gt;再说说我为什么选择&lt;a href=&#34;https://www.asrock.com/mb/Intel/Z390%20Phantom%20Gaming-ITXac/index.cn.asp&#34;&gt;华擎 Z390 Phantom Gaming itx/ac&lt;/a&gt;，&lt;a href=&#34;https://www.chiphell.com/thread-1936969-1-1.html&#34;&gt;超频利器&lt;/a&gt;，双 Ultra M.2（PCIe Gen3 x4 &amp;amp; SATA3）接口（前支持 2260/2280，后支持 2280），4 SATA 3 接口（支持 RAID)和热插拔，DisplayPort 1.2 和 HDMI 2.0，板载 Intel 802.11ac 无线网卡和蓝牙 5.0模块（但不支持黑苹果，伤心），4 口 USB 3.1 Gen2，同时还有 Polychrome Sync RGB 灯控同步方案（虽然我不 care）。不足的地方也有啦，比如最大 32G 内存（支持 64G 就好了），残血雷电3接口（20G/s）再接 eGPU 会比较惨。&lt;/p&gt;

&lt;p&gt;如果你想要大板的话可以考虑华擎 Z390 Extreme 4 或 Taiji，大厂信仰和不差钱的忽略。&lt;/p&gt;

&lt;p&gt;最后附上一个&lt;a href=&#34;https://zhuanlan.zhihu.com/p/50199792&#34;&gt;Z390 主板简单横屏&lt;/a&gt;的文章，对我也很有启发。&lt;/p&gt;

&lt;h3 id=&#34;为什么选择众多漏液全赔的九州风神水冷&#34;&gt;为什么选择众多漏液全赔的九州风神水冷？&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;购买水冷散热器和 9700k 把独立显卡（RX560）的预算花了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;攒机的时候没有考虑散热器的预算本以为如果买 Intel 盒装的版本会带一个小风扇或者随便买个 100 左右的散热器，真正研究配置的时候发现没有自带风扇，可能便宜的风冷 9700k 会压不住，超频就不要想。高塔的风冷（比如大霜塔）会有会挡内存槽和显卡的风险（据说大镰刀有错位设计）毕竟 itx 只有俩内存和一个 PCI-E，权衡下来踩这个坑不如考虑水冷的划算。&lt;/p&gt;

&lt;p&gt;起初看海盗船 H100i v2 用的人挺多，瞅了眼价格直接自我劝退，更何况早期有漏液情况就没敢买，在 pcpartpicker 上筛选水冷散热器排名第二代就是&lt;a href=&#34;http://www.gamerstorm.com/product/CPULIQUIDCOOLER/2017-08/1286_6878.shtml&#34;&gt;九州风神船长 240 White&lt;/a&gt;，尽管也有很多漏液问题但基本上是 2017 年到 2018 年初，后续就再也没有看到漏液爆出（海盗船的现在也没有了）加上价格合适和京东客服再三确认质量保证（质保三年）和漏液全赔之后还是入了一个最便宜的船长 240 特别定制白色 RGB 的版本，结果买回来发现白色的水排和全黑的机箱搭配起来也很不和谐在侧透机箱一览无遗，谁让这个特别版（和国外同步，国内官网没有描述）价格比正常 240 便宜一百块呢。&lt;/p&gt;

&lt;p&gt;关于灯控，散热器自带一个 RGB 控制器同时也支持主板 RGB 同步，插在华擎 Z390 主板 RGB 同步插口上也是可用的（虽然商品描述没有标注支持华擎）&lt;/p&gt;

&lt;p&gt;九州风神作为一个国产品牌说明书是全英文我要给差评，尤其是在第一次接触水冷加 RGB 灯控的菜鸟来说。&lt;/p&gt;

&lt;h3 id=&#34;为什么选择最不像-itx-机箱的追风者-215p&#34;&gt;为什么选择最不像 itx 机箱的追风者 215P？&lt;/h3&gt;

&lt;p&gt;说实话选择这台主机我已经限定了必须是 itx 主板和机箱，中塔以上机箱家里条件不允许而且也不太喜欢较大的体积。选择&lt;a href=&#34;http://www.phanteks.com/Enthoo-Evolv-ITX-TemperedGlass.html&#34;&gt;追风者 215P&lt;/a&gt; 其实是我在找 &lt;a href=&#34;https://bartechtv.com/1000-mini-itx-coffee-lake-hackintosh-build-for-4k-video-editing/&#34;&gt;4k 视频剪辑配置&lt;/a&gt;发现的，国内恰好也有卖，规格还支持高塔风冷、全尺寸显卡以及 280 水冷，价格还合适（虽然不是最低价）没看具体尺寸就买了侧透 RGB 同款，买回来发现恰巧它的优势把机箱宽度拉大，预想的位置宽度正好不够。&lt;/p&gt;

&lt;p&gt;这个机箱的说明书实在是特别的简陋，建议下载国外官方的中文说明书。不知道是不是国内版本减配，没有硬盘灯线和重启线（国外版本说明书是有的），没有也没关系反正机箱也没对于的硬盘灯和重启键，你看到的以为是重启键按钮（国内一些评测也这么认为）实际上是机箱灯控的控制键。&lt;/p&gt;

&lt;p&gt;关于灯控，之前也没接触过灯效也就忽略了京东商品详情的 RGB 灯控的图标标识，一直以为这是一个普通的机箱，后来在看国外商品描述的时候提示是支持华硕，技嘉和微星主板 RGB 同步，看油管说是如果要和主板同步就要拆了机箱前面板把里面的控制版拆掉把 4pin 接口接入到主板的灯控口才行。写这篇博文的时候因为各种不确定我又扒了一遍所有商品的描述，在国外商品详情描述上看到了一行在说明书都没有提到的文字 &lt;code&gt;RGB Montherboard adapter required(sold separately)&lt;/code&gt;，也就是说需要主板 RGB 同步的用户们来掏钱单独买&lt;a href=&#34;http://www.phanteks.com/PH-CB_RGB4P.html&#34;&gt;适配器&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;关于水冷，支持分体式水冷系统。&lt;/p&gt;

&lt;h3 id=&#34;为什么内存不上双通道&#34;&gt;为什么内存不上双通道？&lt;/h3&gt;

&lt;p&gt;不是我不想上双通道，双条 8G 的价格和单条 16G 的价格基本保持一致，在现有预算情况下只是恰巧 DDR4 3000 16G 的价格符合我的要求，不用考虑二手卖掉旧内存直接上新，要知道几年后卖二手内存就太廉价了。&lt;/p&gt;

&lt;p&gt;品牌的话海盗船、芝奇、镁光、威刚、金士顿都可以考虑，需要注意带马甲的内存条是否挡风冷散热器。&lt;/p&gt;

&lt;h3 id=&#34;为什么选择-amd-rx-500-系列独立显卡&#34;&gt;为什么选择 AMD RX 500 系列独立显卡？&lt;/h3&gt;

&lt;p&gt;AMX RX 500 系列和更好的 R9 系列全系 macOS 免驱的，AMD 和 Apple 已经达成长期合作伙伴。免驱动是安装黑苹果抉择的最重要的原因，其次选择 RX 500 系列价格实惠，尤其考虑 RX 560。虽然部分 NVIDIA 显卡有 Web Driver 驱动但据说性能大大折扣，这里推荐黑果小兵整理的 &lt;a href=&#34;https://blog.daliansky.net/Mojave-Hardware-Support-List.html&#34;&gt;macOS 10.14 Majave 硬件支持列表&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;视频剪辑其实并不太吃显卡，主要还是 CPU，CPU 不足的晴朗下才会选择显卡。国外众多兼容黑苹果的配置中大多没有用更好的显卡。&lt;/p&gt;

&lt;h3 id=&#34;为什么选择这么少容量的-ssd&#34;&gt;为什么选择这么少容量的 SSD？&lt;/h3&gt;

&lt;p&gt;如果你不差钱的话请上三星 970 EVO 500G。&lt;/p&gt;

&lt;p&gt;上面提到主板支持双 Ultra M.2 插口和 4 SATA 3.0，同时还支持 &lt;a href=&#34;https://www.youtube.com/watch?v=qg1Vvh67Efw&#34;&gt;RAID0/1/2/3/4/5/10&lt;/a&gt;，其中一个 M.2 插口会被无线+蓝牙模块占用，因此我还剩下一个 M.2 和 4 个 SATA。&lt;/p&gt;

&lt;p&gt;对于我来说在不考虑 RAID 和手里只有比较少 SSD 硬盘的情况我会考虑买一个三星 970 EVO 250G，配合拆掉临时使用的 Windows 系统的老笔记本上的镁光 RX200 SSD 硬盘，这两块分别安装 macOS 和 Windows 系统。SSD 用来做系统安装和常用 App，大数据后期我会在买大容量机械硬盘做支持，最近价格涨上去不少。&lt;/p&gt;

&lt;p&gt;当前因为有 HP Gen 8 做 NAS，在用 LightRoom 修片也基本够用。影视资源也基本上是通过 NAS 的网络协议直接拉取到电脑或者盒子上硬解播放 4k 也毫无压力。&lt;/p&gt;

&lt;h3 id=&#34;为什么要选择博通的无线网卡方案&#34;&gt;为什么要选择博通的无线网卡方案？&lt;/h3&gt;

&lt;p&gt;首先博通是 Apple 的合作厂家，所有 Mac 主机的无线模块都是他家提供的，可以做到真正免驱同时以下提到的同时还支持蓝牙模块。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;蓝牙模块不仅仅是日常连接鼠标，键盘、耳机音箱，它作为 macOS 系统的核心功能是实现 Handoff 和 AirDrop 功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模块&lt;/th&gt;
&lt;th&gt;天线&lt;/th&gt;
&lt;th&gt;网卡&lt;/th&gt;
&lt;th&gt;蓝牙&lt;/th&gt;
&lt;th&gt;插口&lt;/th&gt;
&lt;th&gt;价格&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BCM94360CD&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2.4G 450M+/5G 1300M=1750M&lt;/td&gt;
&lt;td&gt;4.0&lt;/td&gt;
&lt;td&gt;PCI-E&lt;/td&gt;
&lt;td&gt;268&lt;/td&gt;
&lt;td&gt;顶配，请勿购买三天线版本，三天线版本蓝牙和无线共用一根影响使用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BCM94360CS2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2.4G 300M+/5G 867M=1167M&lt;/td&gt;
&lt;td&gt;4.0&lt;/td&gt;
&lt;td&gt;PCI-E&lt;/td&gt;
&lt;td&gt;60-90&lt;/td&gt;
&lt;td&gt;性价比最好，价格低廉差价的入手&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BCM94352Z&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2.4G 300M/5.0G 867M=1167M&lt;/td&gt;
&lt;td&gt;4.0&lt;/td&gt;
&lt;td&gt;M.2&lt;/td&gt;
&lt;td&gt;130&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BCM943602CS&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2.4G 450M+/5G 1300M=1750M&lt;/td&gt;
&lt;td&gt;4.1&lt;/td&gt;
&lt;td&gt;M.2&lt;/td&gt;
&lt;td&gt;178&lt;/td&gt;
&lt;td&gt;94360CD 变种&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BCM94360CSAX&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2.4G 216M+/5G 1300M=1750M&lt;/td&gt;
&lt;td&gt;4.1&lt;/td&gt;
&lt;td&gt;M.2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;94360CD 变种，据说驱动不完美&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BCM943602CDP&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2.4G 450M+&lt;/td&gt;
&lt;td&gt;4.1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;94360CD 升级版，3T3R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BCM94360HMB&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2.4G 450M+&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;华硕主板拆件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BCM943602BAED&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2.4G 450M+&lt;/td&gt;
&lt;td&gt;4.1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;DELL DW1830 拆件，3T3R&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更多型号列表请看 &lt;a href=&#34;https://osxlatitude.com/forums/topic/2120-inventory-of-supportedunsupported-wireless-cards-1-snow-leopard-el-capitan/&#34;&gt;osxlatitude 的整理&lt;/a&gt;（持续更新）&lt;/p&gt;

&lt;p&gt;首先排除 PCI-E 接口华擎 Z390 itx 版只有一个 PCI-E 接口这个是为以后独立显卡准备的，虽然我很想入 BCM94360CD 四天线。 因此只能考虑 M.2 接口，上面的模块虽然也可以直接插 M.2 接口（底子还是 PCI-E 嘛）但板子仅支持 2260/2280，支持 2260 的口我已经插了 SSD（因为主板提供散热马甲），因此我只能考虑 2280。淘宝上能找到的支持 2280 转接卡的模块基本上只有 BCM94360CS2 和 BCM943602CS，考虑到后者是较新的 5G 可以达到 1300M，这俩价格也差不多基本上会考虑后者。 为什么说是考虑呢，因为当前刚好赶上春节卖家已经长期离线了！&lt;/p&gt;

&lt;p&gt;如果你不需要蓝牙的话也可以考虑 USB 无线网卡，USB 类型的目前暂无网卡和蓝牙二合一可用的硬件，虽然市面上已经出了一些。&lt;/p&gt;

&lt;h3 id=&#34;为什么选择-lg-27ul600-显示器&#34;&gt;为什么选择 LG 27UL600 显示器？&lt;/h3&gt;

&lt;p&gt;家里还在服役的 DELL 2209wa 是我 2010 年购入能坚持到现在已经是个奇迹了，16:10 画面在玩 PS4 时会让画面拉伸，屏幕被植物长期亲密接触屏幕出现了一些坏点，在和老婆大人协商后加购预算购买新显示器。这也就有了这个为什么的出现。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.lg.com/cn/monitors/lg-27UL600&#34;&gt;LG 27UL600&lt;/a&gt; 应该是 2019 年初我找到的国内性价比最高的 4k 显示器了吧。27 寸 4k 分辨率，IPS 屏，支持 DisplayHDR 400，sRGB 99% 色域，DisplayPort 1.2 和 HDMI 2.0 接口（兼容 HDCP 2.2设备），3.5mm 音频输出接口。 缺点是底座垃圾，敲下电脑桌就有可能会让显示器晃悠一会，建议直接上摇臂支架（反正我支架是现成的把老显示器卸下来就行了）。&lt;/p&gt;

&lt;p&gt;关于网上有些人说 27 寸用 4k 会特别难受的问题，我表示 Windows 和黑苹果可以字体缩放 200% 用起来非常舒服。&lt;/p&gt;

&lt;p&gt;题外话，这款显示器是 27UD69-W 的升级款。如果你不考虑 sRGB 99% 色域的话入手 27UD58-B 也是不错的选择。&lt;/p&gt;

&lt;h3 id=&#34;为什么没有黑苹果安装教程&#34;&gt;为什么没有黑苹果安装教程？&lt;/h3&gt;

&lt;p&gt;等我装好了测试没问题就写，还是说你愿意看到一个没有实践过的版本？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>升级 HP MicroServer Gen8 iLO 秘笈</title>
      <link>http://icyleaf.com/2018/11/upgrade-hp-microerver-gen8-ilo</link>
      <pubDate>Tue, 27 Nov 2018 10:43:07 +0800</pubDate>
      
      <guid>http://icyleaf.com/2018/11/upgrade-hp-microerver-gen8-ilo</guid>
      <description>

&lt;p&gt;几年前听取网络上的建议德淘了一台 HP MicroServer Gen8 服务器作为家用的 NAS 服务器，德淘的原因除了便宜以外电源的功率比国内版的更大，内存也比国内版的大（4G）。
Gen 8 自带 iLO 这是一个很强大的功能，新出的 Gen10 虽然硬件各方面有不错的表现但却阉割了 iLO，打算入坑谨慎选择。&lt;/p&gt;

&lt;h2 id=&#34;给你鱼&#34;&gt;给你鱼&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://pan.baidu.com/s/1wSMlqg-iVO80U-5Z-kNdQA&#34;&gt;https://pan.baidu.com/s/1wSMlqg-iVO80U-5Z-kNdQA&lt;/a&gt; 提取码: w8mq&lt;/p&gt;

&lt;h2 id=&#34;教你渔&#34;&gt;教你渔&lt;/h2&gt;

&lt;p&gt;本方法适用于你当前操作的电脑系统是任何操作系统。&lt;/p&gt;

&lt;h3 id=&#34;版本概念&#34;&gt;版本概念&lt;/h3&gt;

&lt;p&gt;iLO 当前的版本分为&lt;strong&gt;硬件版本&lt;/strong&gt;和&lt;strong&gt;软件版本&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;硬件版本目前主要是 iLO4 和 iLO 5，后者是 Gen10 在使用。登录 iLO 管理后台页面的头部会提示你 iLO4/5。&lt;/li&gt;
&lt;li&gt;软件版本目前 iLO4 的最新版本是 2.6.1，iLO5 因为用不上没有做了解。在 iLO 管理后台登录界面上会有一行小字提示。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;升级固件&#34;&gt;升级固件&lt;/h3&gt;

&lt;p&gt;打开 &lt;a href=&#34;https://support.hpe.com/hpesc/public/home&#34;&gt;HPE 网站&lt;/a&gt; 搜索关键词 &amp;ldquo;HPE ProLiant MicroServer Gen8 Server&amp;rdquo;，
不要着急回车稍等片刻等有个浮层显示后点击”驱动和文件下载“。&lt;/p&gt;

&lt;p&gt;下载 iLO 固件的可通过左侧的筛选过滤选择 ”固件（Firmware）更新 - Lights-Out Management“ 然后在右侧选择日期是最新的一个对应你操作系统的版本。
如果是 macOS 或没有支持的操作系统也没关系选择任意 Windows 的版本，然后在详情页面点击下载。&lt;/p&gt;

&lt;p&gt;如果你下载后的 exe 文件，通过解压文件可直接进行解压缩能看到里面的 bin 文件，这个实际上是通过 iLO 管理后台升级所用的关键文件。&lt;/p&gt;

&lt;p&gt;操作路径：Administrator -&amp;gt; Framware&lt;/p&gt;

&lt;h3 id=&#34;安装语言包&#34;&gt;安装语言包&lt;/h3&gt;

&lt;p&gt;还是在刚才的搜索结果页面重置并新过滤”应用软件 - Lights-Out Management“，因为语言包更新到频次没那么高，你需要把右侧最底部显示的条目数改为全部（All）
后通过搜索关键词 ”Lights-Out 4 Language Pack“ 找到你希望使用的语言包，截至目前最新的中文语言包（Simplified Chinese ）是 2017 年的，下载过程同上面。&lt;/p&gt;

&lt;p&gt;解压缩文件后只需要里面的 lpk 文件。&lt;/p&gt;

&lt;p&gt;操作路径：Administrator -&amp;gt; Access Settings -&amp;gt; Language&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何解决 macOS 编译丢失 C Header 文件</title>
      <link>http://icyleaf.com/2018/10/apply-for-a-motorcycle-license</link>
      <pubDate>Wed, 24 Oct 2018 14:30:07 +0800</pubDate>
      
      <guid>http://icyleaf.com/2018/10/apply-for-a-motorcycle-license</guid>
      <description>&lt;p&gt;今天在 macOS 10.14 通过 brew 安装 libgit2 之后调用时提示提示 &lt;code&gt;fatal error: &#39;time.h&#39; file not found&lt;/code&gt;，本以为是 brew 的问题自己去编译问题依然。
确认了 Xcode Command Line Tools 并且再次确认了 &lt;code&gt;xcode-select -s /Applications/Xcode.app&lt;/code&gt; 之后还是这样，就连重启大法也不用之后，
在 Google 上检索换了好些关键词也没找到问题出在哪，索性把关键词继续模糊放大扩大范围，看到了 github 一个不知道是啥的项目看到有 &lt;code&gt;&#39;stdio.h.h&#39; file not found&lt;/code&gt;
类似的 issue 终于找到了&lt;a href=&#34;https://github.com/frida/frida/issues/338#issuecomment-424595668&#34;&gt;解决答案&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;关键原因是在于找不到 /usr/include 目录，然而安装 command-line tools 也不会自动帮你解决，而是需要在安装后再手动安装 /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg 才行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;跟随这个解决方案也附带了&lt;a href=&#34;https://forums.developer.apple.com/thread/104296&#34;&gt;解释&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;From the latest Xcode 10 Beta 2 release notes.&lt;/p&gt;

&lt;p&gt;The Command Line Tools package installs the macOS system headers inside the macOS SDK. Software that compiles with the installed tools will search for macOS headers at the standard include path: /Applications/Xcodebeta.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.1 4.sdk/usr/include For legacy software that looks for the macOS headers in the base system under /usr/include, please install the package file located at: /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>ḫpr - 最好用的 git 仓库镜像同步工具</title>
      <link>http://icyleaf.com/2018/04/intro-hpr</link>
      <pubDate>Fri, 27 Apr 2018 18:12:23 +0800</pubDate>
      
      <guid>http://icyleaf.com/2018/04/intro-hpr</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://github.com/icyleaf/hpr/raw/master/docs/_media/icon.png&#34; alt=&#34;icon&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://icyleaf.github.io/hpr/&#34;&gt;ḫpr&lt;/a&gt; 是一个把任意 git 仓库的镜像到 gitlab 服务的同步工具，还支持定期同步的功能。&lt;/p&gt;

&lt;p&gt;特性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持 Web API 接口，可用于远程控制不仅限于终端使用&lt;/li&gt;
&lt;li&gt;支持终端命令控制，方便临时使用&lt;/li&gt;
&lt;li&gt;定时更新镜像的仓库，时间可调，告别不靠谱的 crontab&lt;/li&gt;
&lt;li&gt;几乎支持所有的 git 托管的仓库&lt;/li&gt;
&lt;li&gt;使用可独立部署的 Gitlab 作为镜像平台&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本工具可以用到的地方:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;任意 git 仓库源码的定期同步&lt;/li&gt;
&lt;li&gt;Cocoapods 的境内加速和同步&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;契子&#34;&gt;契子&lt;/h2&gt;

&lt;p&gt;如果关注我博客的用户或者曾经看到过另外一篇文章&lt;a href=&#34;http://icyleaf.com/2015/01/speed-up-cocoapods/&#34;&gt;极速化 CocoaPods&lt;/a&gt;的话且实践的用户会明白为什么会有它的产生。
在我发布那篇文章的时候那套体系已经在我们公司的服务器上运行且截至目前已经持续运行了 3 年多！&lt;/p&gt;

&lt;p&gt;那个方案并不完美，除了调用必须通过脚本的蹩脚的方案外出问题最多的主要是 gitlab-mirrors
只能使用 crontab 做定时任务这样会因多个镜像在同步未完成的情况下重复开启新的同步任务，一个任务不明显一旦积攒多了起来还会慢慢的蚕食内存因此又不得不 ssh 到服务器
开始杀进程相当于重置。&lt;/p&gt;

&lt;p&gt;当时想重新做一个的想法其实 2017 年就产生了用 ruby 写了个头当时项目命名为 nightwing 但 ruby 的问题在部署上面有比较麻烦需要各种依赖环境，
当时也考虑过 Go 但由于在断断续续学习没有持续，这个时候就开始将注意力转移到了类 Ruby 语法的 Crystal 语言，通过业余时间慢慢的了解和确定其性能后虽然和
 Go 来比打包还没有那么高的集成度但完成核心功能已经完全足够，也就开始了封装 &lt;a href=&#34;https://github.com/icyleaf/gitlab.cr&#34;&gt;gitlab&lt;/a&gt;、
&lt;a href=&#34;https://github.com/icyleaf/halite&#34;&gt;halite&lt;/a&gt; 网络库直到最近基本完成了核心功能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ḫpr&lt;/code&gt; 就这样诞生了。项目名和 Logo 出处来源于&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%81%96%E7%94%B2%E8%9F%B2&#34;&gt;圣甲虫&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;快速上手&#34;&gt;快速上手&lt;/h2&gt;

&lt;p&gt;鉴于 Docker 的便利性，目前教程只提供此种方法进行安装部署，首先克隆本项目：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/icyleaf/hpr.git
$ cd hpr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制 &lt;a href=&#34;config/hpr.json.example&#34;&gt;config/hpr.json.example&lt;/a&gt; 并改名 &lt;code&gt;config/config.json&lt;/code&gt; 后可修改&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;schedule_in&amp;quot;: &amp;quot;1.day&amp;quot;,
  &amp;quot;basic_auth&amp;quot;: {
    &amp;quot;enable&amp;quot;: false,
    &amp;quot;user&amp;quot;: &amp;quot;hpr&amp;quot;,
    &amp;quot;password&amp;quot;: &amp;quot;p@ssw0rd&amp;quot;
  },
  &amp;quot;gitlab&amp;quot;: {
    &amp;quot;ssh_port&amp;quot;: 22,
    &amp;quot;endpoint&amp;quot;: &amp;quot;http://gitlab.example.com/api/v3&amp;quot;,
    &amp;quot;private_token&amp;quot;: &amp;quot;abc&amp;quot;,

    &amp;quot;group_name&amp;quot;: &amp;quot;mirrors&amp;quot;,

    &amp;quot;project_public&amp;quot;: false,
    &amp;quot;project_issue&amp;quot;: false,
    &amp;quot;project_wiki&amp;quot;: false,
    &amp;quot;project_merge_request&amp;quot;: false,
    &amp;quot;project_snippet&amp;quot;: false
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;核心需要修改的参数有如下四项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;endpoint&lt;/code&gt;: Gitlab API 的地址，&lt;strong&gt;无需修改后面部分&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private_token&lt;/code&gt;: 在个人设置的 Account 页面获得&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group_name&lt;/code&gt;: 项目镜像的项目都会归属到这个组内，&lt;strong&gt;务必确保你的账户拥有创建组的权限&lt;/strong&gt; (如果是管理员请忽略加粗字样)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ssh_port&lt;/code&gt;: 如果 SSH 不是 22 端口的话需要根据你的实际情况修改&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置文件修改保存后还需要在 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件中配置下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;2&#39;

services:
  hpr:
    image: icyleafcn/hpr
    ports:
      - 8848:8848
    volumes:
      - ./config:/app/config
      - ./repositories:/app/repositories
    environment:
      REDIS_URL: tcp://redis:6379
      REDIS_PROVIDER: REDIS_URL

      HPR_SSH_HOST: git.example.com
      HPR_SSH_PORT: 22
    depends_on:
      - redis
  redis:
    image: redis:alpine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;HPR_SSH_HOST&lt;/code&gt; 和 &lt;code&gt;HPR_SSH_PORT&lt;/code&gt; 变量用于设置 Docker 实例中的 SSH 配置。如果 SSH 端口是 22 的可忽略设置这俩参数。&lt;/p&gt;

&lt;p&gt;编辑完成后运行下面命令快完成了！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose up
...
hpr_1      | Generating public/private rsa key pair ...
hpr_1      |
hpr_1      | GENERATED SSH PUBLIC KEY:
hpr_1      | ##################################################################
hpr_1      | ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDq8O3HbLn9x8Uy8RUotlpOnxdakrmCyDpZrGBeLARmEbd6BOIBQ+UWm8NUKthQ7UOavmlsq4j8lY4kyFW2eFX2qWcbvI+s2gI+05MXax+mAukSszaNSnpAoTyJCRipilSkqiOV99V8JIJhrHPtTO0o/Ui
9WiyyWsUM4M9lEKHpZ486lDGk3IM2XQW+pxAoMKb0TYzqCsrduHUtjzy0M0BqgMPe9EtVQqCbnTMzDLXmRONoTYyTV51NQ12mMwEQcDaLQ28e5gqouQJKS81JaoRpQWa7pHsOCki6Fk9TB+EQFrGz5nOrmYYM+O1MKnFkzmVHv7Fh50Sz7d2nYzzOKAkR hpr@docker
hpr_1      | ##################################################################
hpr_1      |
hpr_1      | Configuring ssh config ...
hpr_1      | Starting hpr server ...
hpr_1      |   _
hpr_1      |  | |__  _ __  _ __
hpr_1      |  | &#39;_ \| &#39;_ \| &#39;__|
hpr_1      |  | | | | |_) | |
hpr_1      |  |_| |_| .__/|_|
hpr_1      |        |_|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后从执行命令的输出找到生成的 SSH PUBLIC KEY（两个井号中间的部分，以 &lt;code&gt;ssh-rsa&lt;/code&gt; 开头，&lt;code&gt;hpr@docker&lt;/code&gt; 结尾），
复制添加到 gitlab 的账户 SSH Keys 页面中。&lt;/p&gt;

&lt;h2 id=&#34;更多资源&#34;&gt;更多资源&lt;/h2&gt;

&lt;p&gt;再多的内容我已经整理到文档中，欢迎移步浏览：&lt;a href=&#34;https://icyleaf.github.io/hpr/&#34;&gt;https://icyleaf.github.io/hpr/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一招解决苹果账户因忘记安全问题绑定手机号</title>
      <link>http://icyleaf.com/2018/04/how-to-bind-mobile-number-to-apple-developer-account</link>
      <pubDate>Fri, 27 Apr 2018 18:00:07 +0800</pubDate>
      
      <guid>http://icyleaf.com/2018/04/how-to-bind-mobile-number-to-apple-developer-account</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;2018 年 4 月初的某天，苹果针对于开发者账户抛出了一个看似只有在中国实施的政策：账户需绑定手机号。
但如果你记得账户登录密码却忘记了安全问题的答案，那你就不能绑定手机号和后续操作。我是亲身经历这个事件且过程都发在了 twitter
上面，期间也有很多朋友帮忙跟进和给出不少建议。我希望国内的用户通过搜索引擎找到这里来解决问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你只想看到最有效的解决方案请拉到文章的尾部的&lt;strong&gt;一招解决&lt;/strong&gt;，中间提到的一些解决方案可能在你那边也会适用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;亲身经历&#34;&gt;亲身经历&lt;/h2&gt;

&lt;p&gt;对于绑定手机号来说，乍一看这算啥我不绑定你能咋滴！然而我们都太 naive，直到某一天我要对一个快过期的账户续费的时候发现了一个巨大的坑。
也就是说如果你没有绑定手机号你讲不能下述操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不能接受最新苹果的协议更新 （这算事？）&lt;/li&gt;
&lt;li&gt;不能对已上架的 App 新建版本&lt;/li&gt;
&lt;li&gt;不能新建新 App&lt;/li&gt;
&lt;li&gt;不能对账户进行续费（你没看错，我通过技术手段获取了续费链接打开还是要你绑定手机号！）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;老老实实的去绑定手机号，首先它会跳转到 appleid.apple.com 网站提示登录，如往常一样输入用户名密码点击登录，映入眼帘不是登录成功后
的界面而是让你输入安全问题的答案。由于公司涉及的多个账户最初并不是我来申请的，赶紧联系前同事求助得到的答案是我当时瞎填的，我&amp;hellip;&lt;/p&gt;

&lt;p&gt;第一时间打苹果客服 &lt;code&gt;400-009-5555&lt;/code&gt; 接通后说明问题希望能够重设安全问题，这个时候苹果一如既往的保持高安全性的答复如果你忘记了安全问题
的答案那这个帐号基本上就废了。但如果你这个是开发者账户的话可以通过两种方式尝试解决：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用手机登录该账户后尝试开启两步验证，如果没有提示安全问题开启后就可以重置，若有提示那此路不通。&lt;/li&gt;
&lt;li&gt;求助苹果开发者客服 &lt;code&gt;400-670-1855&lt;/code&gt;，看看他们那边怎么处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;推友 &lt;a href=&#34;https://twitter.com/frankxzx624&#34;&gt;@frankxzx&lt;/a&gt; 给我建议说如果开发者账户如果绑定了紧急邮箱也可以重设，但不适用于我的情况有类似需求的可以尝试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;找了台测试机尝试方案一结果还是显示安全问题，只能寄希望于苹果开发者客服。通过几天的跟进我认为这个电话非常的坑爹，因为接通会进入等待列表，
语音还特别提示“你的电话非常重要，请耐心等待”，但通常情况下你需要 1 ~ 2 个小时才能接通，建议打这个电话的时候用一个蓝牙耳机会能让你先忙
于其他的事情。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;推友 &lt;a href=&#34;https://twitter.com/Lonely__Ma&#34;&gt;@Lonely&lt;/a&gt; 给我建议是每天早上 9 点拨打秒接通，但那个时间点我一般在路上没有尝试。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个星期的时间我总共打通过两次，第一次给的服务还不错说情况比较复杂他的权限不能够解决，但可以给我的几个账户进行安全升级并向上级反馈并耐心
等待答复又不能保证什么时候会答复，给了我一个案例编号说你可以再次拨打客服电话报上案例编号就可以查到进度。&lt;/p&gt;

&lt;p&gt;第二次拨打是 4 天后花了 1 个半小时接通，一个说中文比较费劲的技术人员告诉我你不是账户的持有人找你们的老板来打这个电话才行（哪个老板可以每天花
1 - 2 小时等待时间给你打电话还不一定能接通），跟他说了你们电话太难打了我花了快 2 小时才打通啊，这又不是随随便便就能接通的。然后有说你可以
给我们(&lt;code&gt;chinadev@asia.apple.com&lt;/code&gt;)发邮件我们会尽快回复的，但邮件必须是通过有问题的 apple id 账户的邮箱发出才行。&lt;/p&gt;

&lt;p&gt;感谢后挂了我就登录 apple id 的邮箱系统依次发了邮件希望能够尽快处理，因为一个账户还有 3 天就续费过期了。在看到 Apple 自动恢复的邮件显示
“我们会在一天内给你答复”&lt;/p&gt;

&lt;p&gt;第一天过去了没有收到答复，第二天过去了还没有收到答复&amp;hellip;第三天开发者账户已经过期依然没有收到答复&amp;hellip;&lt;/p&gt;

&lt;p&gt;就在我绝望之际，我看到了曙光。&lt;/p&gt;

&lt;h2 id=&#34;一招解决&#34;&gt;一招解决&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;截至 2018 年 4 月 27 日该方法有效。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;推友 &lt;a href=&#34;https://twitter.com/shanegood&#34;&gt;@shanegood&lt;/a&gt; 和 &lt;a href=&#34;https://twitter.com/lipeiqiang&#34;&gt;@lipeiqiang&lt;/a&gt; 在第一时间提醒我通过 macOS 登录
iCloud 更新联系方式的方式可以添加绑定手机号。在本机新建了多个用户对于不同的账户依次登录 iCloud 确实可以绑定手机号！但重设安全问题是无解的。&lt;/p&gt;

&lt;p&gt;对于绑定的手机号必须是没有绑定过其他 Apple Id 账户的才行，于是我通过阿里小号 App 和我另外一个大王卡小号绑定了公司的开发者帐号。蛋疼！&lt;/p&gt;

&lt;p&gt;感谢在这个事件中给予帮助的推友也希望本文能够帮助你解决问题。完整的时间线都在我的 twitter 上面记录，欢迎 &lt;a href=&#34;https://twitter.com/icyleaf&#34;&gt;follow&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何使用 Docker 管理 Jenkins</title>
      <link>http://icyleaf.com/2018/04/how-to-manage-jenkins-with-docker</link>
      <pubDate>Wed, 18 Apr 2018 14:44:32 +0800</pubDate>
      
      <guid>http://icyleaf.com/2018/04/how-to-manage-jenkins-with-docker</guid>
      <description>

&lt;p&gt;官方的 &lt;a href=&#34;https://hub.docker.com/_/jenkins&#34;&gt;jenkins&lt;/a&gt; 镜像已经不再维护管理而是由 Jenkins Community 进行更新，鉴于 Jenkins 的更新频率特别快社区版本会提供两个版本：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lts&lt;/code&gt; 长期稳定版本，但还是会有新版提醒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;latest&lt;/code&gt; 每周更新版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;都是基于 alpine 系统封装因此镜像的体积会大大减小很多。如果你是内网使用可以不用在意更新问题长期使用一个版本也没太大问题。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;创建镜像时需要注意几个地方：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;关联本地 volumes&lt;/li&gt;
&lt;li&gt;设置时区（默认是 UTC 时间）&lt;/li&gt;
&lt;li&gt;映射 50000 端口（这个是 master 和 slave 的通讯端口）和 8000 端口（Web）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;docker run -d --restart=always
    -p 8000:8080 -p 50000:50000
    -v /var/lib/docker/jenkins:/var/jenkins_home
    -e JAVA_OPTS=-Duser.timezone=Asia/Shanghai
    jenkins/jenkins:lts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于进行设置 JAVA 的参数可以参考：&lt;a href=&#34;https://github.com/jenkinsci/docker/issues/45&#34;&gt;https://github.com/jenkinsci/docker/issues/45&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置-jenkins-的插件源&#34;&gt;配置 Jenkins 的插件源&lt;/h2&gt;

&lt;p&gt;使用过它的人都知道管理和安装插件是一个奇慢无比的事情，虽然提供了代理服务器但我这还有一个更好的方案。&lt;/p&gt;

&lt;p&gt;我在翻阅国内镜像源网站的时候发现清华大学开源软件镜像站其实提供了国内 Jenkins 插件的镜像源但一直很低调的没有公布，通过进入&lt;code&gt;管理插件 -&amp;gt; 高级&lt;/code&gt;页面拉到最底部有个升级站点的自定义框，填入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装插件的时候系统默认会测试网络就是 ping 下 Google 的网站，它会提示失败但不用担心它会继续尝试下载和安装插件。&lt;/p&gt;

&lt;h2 id=&#34;升级&#34;&gt;升级&lt;/h2&gt;

&lt;p&gt;此方法适用于所有的容器的升级步骤。&lt;/p&gt;

&lt;p&gt;首先需要找到容器的名字，这里我想会有不少人会问为什么你在创建一个容器的时候不指定一个名字，
那是因为后面还需要创建一个新版本的容器而名字不能一样，因此我现在创建都让 docker 随机分配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID  ...   NAMES
8f48718fdd07  ...   naughty_pasteur
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拿到之后先停止运行后，创建一个数据备份容器再进行拉取最新版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker stop naughty_pasteur
$ docker docker create --volumes-from naughty_pasteur --name jenkins-data jenkins/jenkins:lts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拉取最新版本后恢复数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker pull jenkins/jenkins:lts
$ docker run -d --restart=always
    --volumes-from jenkins-data
    -p 8000:8080 -p 50000:50000
    -v /var/lib/docker/jenkins:/var/jenkins_home
    -e JAVA_OPTS=-Duser.timezone=Asia/Shanghai
    jenkins/jenkins:lts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确保通过 web 访问和 build 正常后删除老的和数据备份的容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker rm naughty_pasteur
$ docker rm jenkins-data
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;疑惑解答&#34;&gt;疑惑解答&lt;/h2&gt;

&lt;h3 id=&#34;1-我忘记设置时区但我进实例修改了时区在-jenkins-里不生效&#34;&gt;1. 我忘记设置时区但我进实例修改了时区在 Jenkins 里不生效&lt;/h3&gt;

&lt;p&gt;在 Jenkins 的系统设置页面找到脚本命令行运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.setProperty(&#39;org.apache.commons.jelly.tags.fmt.timeZone&#39;, &#39;Asia/Shanghai&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后即时生效无需重启，方法来自&lt;a href=&#34;https://wiki.jenkins.io/display/JENKINS/Change+time+zone&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;官方文档&#34;&gt;官方文档&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jenkinsci/docker/blob/master/README.md&#34;&gt;https://github.com/jenkinsci/docker/blob/master/README.md&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fast Crystal</title>
      <link>http://icyleaf.com/2017/05/fast-crystal</link>
      <pubDate>Wed, 10 May 2017 11:57:58 +0000</pubDate>
      
      <guid>http://icyleaf.com/2017/05/fast-crystal</guid>
      <description>&lt;p&gt;起初是自己写了一个小测试来看看 crystal 下连接字符串几种实现方式的性能情况，结果还真能区分出来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ crystal build --release code/string/concatenation.cr -o bin/string/concatenation
$ ./bin/string/concatenation

Crystal 0.22.0 (2017-04-22) LLVM 4.0.0

 String#+  32.98M ( 30.32ns) (±11.62%)       fastest
String#{}   9.51M (105.16ns) (± 6.12%)  3.47× slower
 String#%    5.0M (200.03ns) (± 4.81%)  6.60× slower
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是就仿照 &lt;a href=&#34;https://github.com/JuanitoFatas/fast-ruby&#34;&gt;fast-ruby&lt;/a&gt; 在周末花了时间 fork 了 crystal 版本，其实结果挺让人吃惊的，因为是编译性语言在大多数情况下一些小的语法糖在编译器优化阶段会做一致性处理最终的结果其实是一样的，但也有一些例外。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/icyleaf/fast-crystal&#34;&gt;https://github.com/icyleaf/fast-crystal&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>打通 Sidekiq 的任督二脉 Ruby 和 Crystal</title>
      <link>http://icyleaf.com/2017/04/sidekiq-works-in-ruby-togethor-with-crystal</link>
      <pubDate>Wed, 26 Apr 2017 16:00:49 +0000</pubDate>
      
      <guid>http://icyleaf.com/2017/04/sidekiq-works-in-ruby-togethor-with-crystal</guid>
      <description>

&lt;p&gt;自从开始研究 Crystal 这门语言（之前也有&lt;a href=&#34;http://icyleaf.com/2016/07/gitlab-api-wrapper-for-crystal/&#34;&gt;介绍&lt;/a&gt;过），基本上每隔一段时间都会看看它的近况，去年 sidekiq 的作者用该语言重新实现了 sidekiq 项目而且给出了特别竟然的&lt;a href=&#34;http://www.mikeperham.com/2016/05/25/sidekiq-for-crystal/&#34;&gt;对比数据&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://icyleaf.com/uploads/2017/04/26/sidekiq-benchmarks.png&#34; alt=&#34;IMAGE&#34; /&gt;&lt;/p&gt;

&lt;p&gt;相对比 Gitlab 采用 go 语言重新 gitlab_ci_runner 而学习一门新的语言达到高效率低内存的方法之外 Crystal 就像是新的希望。使用 Crystal 重新的 sidekiq 的代码也非常的简单但已经实现了核心功能和 Web UI。&lt;/p&gt;

&lt;p&gt;本篇就给大家介绍下如果在 Ruby on Rails 的框架下调度和执行 Crystal 写的 Workers。测试环境是在 macOS 下，其他版本信息如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ruby 2.0+

&lt;ul&gt;
&lt;li&gt;Rails 5.0&lt;/li&gt;
&lt;li&gt;Sidekiq 5.0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Crystal 0.22.0+

&lt;ul&gt;
&lt;li&gt;Sidekiq.cr 0.7.0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置-rails-环境&#34;&gt;配置 Rails 环境&lt;/h2&gt;

&lt;p&gt;如何配置 Ruby、Rails、Bundler、Redis 就不在赘述，只讲核心，首先新建一个最基础的 rails 项目，不用额外的第三方辅助工具，数据库用 sqlite 减少外部依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rails new ruby_on_rails -B -T -S -C -M  -d sqlite3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入项目 &lt;code&gt;ruby_on_rails&lt;/code&gt; 编辑 &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 修改源地址
source &#39;https://gems.ruby-china.org&#39;

# 新增 sidekiq 的支持
gem &#39;redis-rails&#39;
gem &#39;sidekiq&#39;

# 其余的不用修改
# Bundle edge Rails instead: gem &#39;rails&#39;, github: &#39;rails/rails&#39;
gem &#39;rails&#39;, &#39;~&amp;gt; 5.0.2&#39;
# Use sqlite3 as the database for Active Record
gem &#39;sqlite3&#39;
# Use Puma as the app server
gem &#39;puma&#39;, &#39;~&amp;gt; 3.0&#39;

gem &#39;redis-rails&#39;
gem &#39;sidekiq&#39;

group :development, :test do
  # Call &#39;byebug&#39; anywhere in the code to stop execution and get a debugger console
  gem &#39;byebug&#39;, platform: :mri
end

group :development do
  # Access an IRB console on exception pages or by using &amp;lt;%= console %&amp;gt; anywhere in the code.
  gem &#39;web-console&#39;, &#39;&amp;gt;= 3.3.0&#39;
  gem &#39;listen&#39;, &#39;~&amp;gt; 3.0.5&#39;
  # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring
  gem &#39;spring&#39;
  gem &#39;spring-watcher-listen&#39;, &#39;~&amp;gt; 2.0.0&#39;
end

# Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem &#39;tzinfo-data&#39;, platforms: [:mingw, :mswin, :x64_mingw, :jruby]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置好之后执行 &lt;code&gt;bundle insall&lt;/code&gt; 安装好 Gem 的依赖，再创建文件 &lt;code&gt;config/initializers/sidekiq.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;redis_config = { url: &#39;redis://localhost:6379/8&#39; }

Sidekiq.configure_server do |config|
  config.redis = redis_config
end

Sidekiq.configure_client do |config|
  config.redis = redis_config
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sidekiq 的配置就完事了。&lt;/p&gt;

&lt;h2 id=&#34;配置-crystal-环境&#34;&gt;配置 Crystal 环境&lt;/h2&gt;

&lt;p&gt;Crystal 是基于 LLVM 开发，除了 Windows 以外其他绝大数系统基本上都支持（最新支持的 ARM 架构，可在树莓派上安装），&lt;a href=&#34;https://crystal-lang.org/docs/installation/&#34;&gt;安装步骤&lt;/a&gt;同样不再赘述。&lt;/p&gt;

&lt;p&gt;安装好之后首先创建一个新项目：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ crystal init app crystal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入项目 &lt;code&gt;crystal&lt;/code&gt; 编辑 &lt;code&gt;Shard.yml&lt;/code&gt; 这是一个类似于 Gemfile 的功能，但实现的去中心化，在文件末尾新增如下依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;dependencies:
  sidekiq:
    github: mperham/sidekiq.cr
    branch: master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行 &lt;code&gt;shards update&lt;/code&gt; 或 &lt;code&gt;crystal deps&lt;/code&gt; 安装依赖即可。&lt;/p&gt;

&lt;h2 id=&#34;编写-workers&#34;&gt;编写 Workers&lt;/h2&gt;

&lt;p&gt;Worker 的功能很简单，就是做一个类似 Redis ping 的功能，Worker 在日志输出 PONG。&lt;/p&gt;

&lt;h3 id=&#34;ruby-版本&#34;&gt;Ruby 版本&lt;/h3&gt;

&lt;p&gt;安装 sidekiq 后会在 rails 内置命令可生成基础模板，切换到 &lt;code&gt;ruby_on_rails&lt;/code&gt; 目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rails g sidekiq:worker ping1
      create  app/workers/ping1_worker.rb
$ rails g sidekiq:worker ping2
      create  app/workers/ping2_worker.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;worker 的内容也很简单，我在日志输出增加了 &lt;code&gt;[Ruby]&lt;/code&gt; 作为 Ruby 版本的标识便于后面的辨识&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/workers/ping1_worker.rb
class Ping1Worker
  include Sidekiq::Worker

  def perform(*args)
    logger.info &amp;quot;[Ruby] PONG !&amp;quot;
  end
end

# app/workers/ping2_worker.rb
class Ping2Worker
  include Sidekiq::Worker

  def perform(*args)
    logger.info &amp;quot;[Ruby] PONG PONG !!&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;crystal-版本&#34;&gt;Crystal 版本&lt;/h3&gt;

&lt;p&gt;切换到 &lt;code&gt;crystal&lt;/code&gt; 目录下和 Ruby 不同的是它的源码是存放在 src 目录下面，我们稍微调整下结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;.
├── LICENSE
├── README.md
├── lib
├── shard.lock
├── shard.yml
├── spec
└── src
    ├── crystal_server.cr
    └── workers
        ├── ping1_worker.cr
        └── ping2_worker.cr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;worker 的内容如下，并设置 queue 为 &lt;code&gt;crystal&lt;/code&gt; 用于指派使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-crystal&#34;&gt;# src/workers/ping1_worker.cr
class Ping1Worker
  include Sidekiq::Worker
  sidekiq_options do |job|
    job.queue = &amp;quot;crystal&amp;quot;
  end

  def perform()
    logger.info &amp;quot;[Crystal] PONG !&amp;quot;
  end
end

# src/workers/ping2_worker.cr
class Ping2Worker
  include Sidekiq::Worker
  sidekiq_options do |job|
    job.queue = &amp;quot;crystal&amp;quot;
  end

  def perform()
    logger.info &amp;quot;[Crystal] PONG PONG !!&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过代码可以看出 Ruby 和 Crystal 的代码基本上是完全一样的。&lt;/p&gt;

&lt;h2 id=&#34;任督二脉&#34;&gt;任督二脉&lt;/h2&gt;

&lt;p&gt;对于使用 Sidekiq 的童鞋都知道，如果我想执行一个队列任务，只需要调用下 Worker 本身的 &lt;code&gt;perform_*&lt;/code&gt; 方法，这样的话根本无法调用一个不同语言版本的 Worker 否则 sidekiq 会报类似如下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2017-04-26T06:19:14.187Z 50690 TID-ox4qa1k8o WARN: {&amp;quot;context&amp;quot;:&amp;quot;Job raised exception&amp;quot;,&amp;quot;job&amp;quot;:{&amp;quot;class&amp;quot;:&amp;quot;Crystal::Ping1Worker&amp;quot;,&amp;quot;args&amp;quot;:[],&amp;quot;retry&amp;quot;:true,&amp;quot;queue&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;jid&amp;quot;:&amp;quot;42ce106d79
01a274f3db2d54&amp;quot;,&amp;quot;created_at&amp;quot;:1493187554.181674,&amp;quot;enqueued_at&amp;quot;:1493187554.1820428},&amp;quot;jobstr&amp;quot;:&amp;quot;{\&amp;quot;class\&amp;quot;:\&amp;quot;Crystal::Ping1Worker\&amp;quot;,\&amp;quot;args\&amp;quot;:[],\&amp;quot;retry\&amp;quot;:true,\&amp;quot;queue\&amp;quot;:\&amp;quot;default\&amp;quot;,\&amp;quot;jid
\&amp;quot;:\&amp;quot;42ce106d7901a274f3db2d54\&amp;quot;,\&amp;quot;created_at\&amp;quot;:1493187554.181674,\&amp;quot;enqueued_at\&amp;quot;:1493187554.1820428}&amp;quot;}
2017-04-26T06:19:14.187Z 50690 TID-ox4qa1k8o WARN: NameError: uninitialized constant Crystal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打通任督二脉的关键在于两个版本都提供一个 low-level 的 API 可用于定制化调用：&lt;/p&gt;

&lt;h3 id=&#34;ruby-版本-1&#34;&gt;Ruby 版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;job_id = Sidekiq::Client.push(
  &#39;queue&#39; =&amp;gt; &#39;&#39;,  # 指派特定的队列名，默认是 default
  &#39;class&#39; =&amp;gt; &#39;&#39;,  # Worker 的类名，可以是实例化类型或字符串类型
  &#39;args&#39; =&amp;gt;[]     # Worker 接收的参数，以数组形式传递
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;crystal-版本-1&#34;&gt;Crystal 版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-crystal&#34;&gt;job = Sidekiq::Job.new
job.queue = &amp;quot;default&amp;quot;   # 指派特定的队列名，默认是 default
job.klass = &amp;quot;&amp;quot;          # Worker 的类名，可以是实例化类型或字符串类型
job.args = [].to_json   # Worker 接收的参数，以数组形式传递

client = Sidekiq::Client.new
job_id = client.push(job)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;打通任督二脉&#34;&gt;打通任督二脉&lt;/h2&gt;

&lt;p&gt;准备工作就绪，打通任督二脉的关键就只差一个了！那就是对于 redis 数据共享，细心的童鞋可能留意了上面只配置了 Ruby 版本的 redis 连接，但对于 Crystal 我故意留白没有说明。因为这个是最关键的一步，对于当前 sidekiq.cr 版本来说。&lt;/p&gt;

&lt;p&gt;sidekiq.cr 对于作者来说是一次试水并没有话特别大的精力，Crystal 本身还处在开发阶段在未到达 1.0 之前会有各种 Break Changes。而且作者是非常照顾 Heroku 的开发者，默认仅支持该服务平台 Redis-to-Go 服务，因此想设置 Redis 连接信息必须通过系统的环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;REDISTOGO_URL=redis://localhost:6379/8
REDIS_PROVIDER=$REDISTOGO_URL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的配置是不可省略的，因为我个人不懂 Heroku 给作者乱提了 PL 还被作者狠批了一顿 :(&lt;/p&gt;

&lt;p&gt;回到话题本身，我们来继续写上 &lt;code&gt;src/crystal_server.cr&lt;/code&gt; 关键的代码：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：redis 连接信息无比保证和 rails 配置的是一致的！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-crystal&#34;&gt;require &amp;quot;sidekiq&amp;quot;
require &amp;quot;sidekiq/cli&amp;quot;
require &amp;quot;./workers/*&amp;quot;

ENV[&amp;quot;LOCAL_REDIS&amp;quot;] = &amp;quot;redis://localhost:6379/8&amp;quot;
ENV[&amp;quot;REDIS_PROVIDER&amp;quot;] = &amp;quot;LOCAL_REDIS&amp;quot;

cli = Sidekiq::CLI.new
server = cli.configure do |config|
  # 支持中间件，默认留空即可
end

cli.run(server)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码需要编译执行，因为不编译是无法给 sidekiq cli 传递它接受的参数（当然也有方法，我放在末尾范例源码中自己寻找）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ crystal build src/crystal_server.cr -o crystal_server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面命令把源码编译成可执行文件到项目根目录的 &lt;code&gt;crystal_server&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;打开终端一：启动 ruby 的 sidekiq server&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd ruby_on_rails
$ sidekiq -q default
2017-04-26T06:47:19.299Z 76282 TID-owewdljsc INFO: Booting Sidekiq 4.2.10 with redis options {:url=&amp;gt;&amp;quot;redis://localhost:6379/8&amp;quot;}


         m,
         `$b
    .ss,  $$:         .,d$
    `$$P,d$P&#39;    .,md$P&amp;quot;&#39;
     ,$$$$$bmmd$$$P^&#39;
   .d$$$$$$$$$$P&#39;
   $$^&#39; `&amp;quot;^$$$&#39;       ____  _     _      _    _
   $:     ,$$:       / ___|(_) __| | ___| | _(_) __ _
   `b     :$$        \___ \| |/ _` |/ _ \ |/ / |/ _` |
          $$:         ___) | | (_| |  __/   &amp;lt;| | (_| |
          $$         |____/|_|\__,_|\___|_|\_\_|\__, |
        .d$$                                       |_|

2017-04-26T06:47:19.433Z 76282 TID-owewdljsc INFO: Running in ruby 2.4.0p0 (2016-12-24 revision 57164) [x86_64-darwin16]
2017-04-26T06:47:19.433Z 76282 TID-owewdljsc INFO: See LICENSE and the LGPL-3.0 for licensing details.
2017-04-26T06:47:19.433Z 76282 TID-owewdljsc INFO: Upgrade to Sidekiq Pro for more features and support: http://sidekiq.org
2017-04-26T06:47:19.442Z 76282 TID-owewdljsc INFO: Starting processing, hit Ctrl-C to stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开终端二：启动 crystal 的 sidekiq server&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd crystal
$ ./crystal_server -q crystal

         m,
         `$b
    .ss,  $$:         .,d$
    `$$P,d$P&#39;    .,md$P&amp;quot;&#39;
     ,$$$$$bmmd$$$P^&#39;
   .d$$$$$$$$$$P&#39;
   $$^&#39; `&amp;quot;^$$$&#39;       ____  _     _      _    _
   $:     ,$$:       / ___|(_) __| | ___| | _(_) __ _
   `b     :$$        \___ \| |/ _` |/ _ \ |/ / |/ _` |
          $$:         ___) | | (_| |  __/   &amp;lt;| | (_| |
          $$         |____/|_|\__,_|\___|_|\_\_|\__, |
        .d$$                                       |_|

2017-04-26T06:48:42.755Z 83552 TID-21ybwjk  INFO: Sidekiq v0.7.0 in Crystal 0.22.0
2017-04-26T06:48:42.755Z 83552 TID-21ybwjk  INFO: Licensed for use under the terms of the GNU LGPL-3.0 license.
2017-04-26T06:48:42.755Z 83552 TID-21ybwjk  INFO: Upgrade to Sidekiq Enterprise for more features and support: http://sidekiq.org
2017-04-26T06:48:42.755Z 83552 TID-21ybwjk  INFO: Starting processing with 25 workers
2017-04-26T06:48:42.756Z 83552 TID-21ybwjk  INFO: Press Ctrl-C to stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;验证功力效果&#34;&gt;验证功力效果&lt;/h2&gt;

&lt;p&gt;两边的 sidekiq server 都已经跑起来了，我们先从 rails 启动 console 验证，注意留意两个 sidekiq 终端日志的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rails console
Loading development environment (Rails 5.0.2)

# 调用 rails 本身的 ping1 和 ping2 worker
2.4.0 :001 &amp;gt; Sidekiq::Client.push(&#39;class&#39; =&amp;gt; &#39;Ping1Worker&#39;, &#39;args&#39; =&amp;gt;[])
 =&amp;gt; &amp;quot;961500753aa127b73ac50851&amp;quot;
2.4.0 :002 &amp;gt; Sidekiq::Client.push(&#39;class&#39; =&amp;gt; &#39;Ping2Worker&#39;, &#39;args&#39; =&amp;gt;[])
 =&amp;gt; &amp;quot;be366d2e5f44adf367853d82&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应 rails 的 sidekiq server 会同时输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2017-04-26T06:53:01.722Z 76282 TID-owex58ag8 Ping1Worker JID-961500753aa127b73ac50851 INFO: start
2017-04-26T06:53:01.722Z 76282 TID-owex58ag8 Ping1Worker JID-961500753aa127b73ac50851 INFO: [Ruby] PONG !
2017-04-26T06:53:01.722Z 76282 TID-owex58ag8 Ping1Worker JID-961500753aa127b73ac50851 INFO: done: 0.0 sec
2017-04-26T06:53:52.681Z 76282 TID-owex58bs0 Ping2Worker JID-be366d2e5f44adf367853d82 INFO: start
2017-04-26T06:53:52.681Z 76282 TID-owex58bs0 Ping2Worker JID-be366d2e5f44adf367853d82 INFO: [Ruby] PONG PONG !!
2017-04-26T06:53:52.681Z 76282 TID-owex58bs0 Ping2Worker JID-be366d2e5f44adf367853d82 INFO: done: 0.0 sec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自身一脉本来就是通的没什么好稀奇的，验证另外一脉：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rails console
Loading development environment (Rails 5.0.2)

# 调用 crystal 的 ping1 和 ping2 worker
2.4.0 :001 &amp;gt; Sidekiq::Client.push(&#39;class&#39; =&amp;gt; &#39;Ping1Worker&#39;, &#39;args&#39; =&amp;gt;[], &#39;queue&#39; =&amp;gt; &#39;crystal&#39;)
 =&amp;gt; &amp;quot;324cf5e07b5e2999b0a45565&amp;quot;
2.4.0 :002 &amp;gt; Sidekiq::Client.push(&#39;class&#39; =&amp;gt; &#39;Ping2Worker&#39;, &#39;args&#39; =&amp;gt;[], &#39;queue&#39; =&amp;gt; &#39;crystal&#39;)
 =&amp;gt; &amp;quot;06c60bb9d52d9a31d48d2fdc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看 crystal 的 sidekiq server 的日志：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2017-04-26T06:57:11.846Z 21253 TID-1z8q4cg  JID=324cf5e07b5e2999b0a45565 INFO: Start
2017-04-26T06:57:11.846Z 21253 TID-1z8q4cg  JID=324cf5e07b5e2999b0a45565 INFO: [Crystal] PONG !
2017-04-26T06:57:11.846Z 21253 TID-1z8q4cg  JID=324cf5e07b5e2999b0a45565 INFO: Done: 0.000046 sec
2017-04-26T06:57:20.785Z 21253 TID-1z8q3y8  JID=06c60bb9d52d9a31d48d2fdc INFO: Start
2017-04-26T06:57:20.785Z 21253 TID-1z8q3y8  JID=06c60bb9d52d9a31d48d2fdc INFO: [Crystal] PONG PONG !!
2017-04-26T06:57:20.785Z 21253 TID-1z8q3y8  JID=06c60bb9d52d9a31d48d2fdc INFO: Done: 0.000049 sec
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证通过！打通了！&lt;/p&gt;

&lt;p&gt;Crystal 这边向 Ruby 调用也可行，但只有通过如下代码，有个别时候自身调用也没有日志输出，不过在 Web UI 却发现已处理的数字已正常更新，该问题我再调查下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-crystal&#34;&gt;require &amp;quot;sidekiq&amp;quot;

ENV[&amp;quot;LOCAL_REDIS&amp;quot;] = &amp;quot;redis://localhost:6379/8&amp;quot;
ENV[&amp;quot;REDIS_PROVIDER&amp;quot;] = &amp;quot;LOCAL_REDIS&amp;quot;

workers = %w(Ping1Worker Ping2Worker)
workers.each do |wk_class|
  job = Sidekiq::Job.new
  job.queue = &amp;quot;default&amp;quot;
  job.klass = wk_class

  Sidekiq::Client.default_context = Sidekiq::Client::Context.new

  client = Sidekiq::Client.new
  job_id = client.push(job)
  puts &amp;quot;[#{wk_class}] job id: #{job_id}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2017-04-26T07:20:58.754Z 62256 TID-oukzi7jck Ping1Worker JID-1fee81b35052cba1f6525de5 INFO: start
2017-04-26T07:20:58.754Z 62256 TID-oukzi7jck Ping1Worker JID-1fee81b35052cba1f6525de5 INFO: [Ruby] PONG !
2017-04-26T07:20:58.755Z 62256 TID-oukzi7jck Ping1Worker JID-1fee81b35052cba1f6525de5 INFO: done: 0.0 sec
2017-04-26T07:20:58.756Z 62256 TID-oul02vzfw Ping2Worker JID-0bb7eef097447784fb48d943 INFO: start
2017-04-26T07:20:58.756Z 62256 TID-oul02vzfw Ping2Worker JID-0bb7eef097447784fb48d943 INFO: [Ruby] PONG PONG !!
2017-04-26T07:20:58.756Z 62256 TID-oul02vzfw Ping2Worker JID-0bb7eef097447784fb48d943 INFO: done: 0.0 sec
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;本篇只是通过一个最简单的例子让大家知道互通的方法，实际使用中对于数据交互等还有更多需要考虑的地方，这里就暂时不做展开。非常期待 Crystal 今年立的 &lt;a href=&#34;https://crystal-lang.org/2016/12/29/crystal-new-year-resolutions-for-2017-1-0.html&#34;&gt;1.0 的目标&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;对于 Crystal 语言本身的评价，大家也可看下 RubyChina 站长的心得&lt;a href=&#34;https://ruby-china.org/topics/32771&#34;&gt;Crystal 说我最近关注 Crystal 的感受&lt;/a&gt;，编译语言有编译语言的坑，入坑需谨慎。&lt;/p&gt;

&lt;p&gt;本文演示的代码已经整理并放到了 &lt;a href=&#34;https://github.com/icyleaf/sidekiq-with-ruby-and-crystal&#34;&gt;Github&lt;/a&gt;，对于不明白的地方可配合代码更好服用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker 摸爬滚打对抗 CentOS 6</title>
      <link>http://icyleaf.com/2016/12/docker-with-centos</link>
      <pubDate>Fri, 30 Dec 2016 17:52:30 +0800</pubDate>
      
      <guid>http://icyleaf.com/2016/12/docker-with-centos</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;2018年10月18日更新：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;国庆期间恰巧服务器硬盘故障且运维并没有做 raid 备份，给更换了一台新内部服务器，索性升级到了 CentOS 7，因此针对 CentOS 6 安装 Docker 的答疑不再更新。&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;前不久终于把我们移动团队内部服务器从 CentOS 5.x 升级到了 6.8。本来是拜托让升级至 7.0 版本起码能用上 docker 1.12 版本还是靠谱的事情。
事情往往难以预料的被告知其他团队在安装 7.0 之后造成内部服务器群的网卡失灵的诡异故障只能作罢，想想起码还有个早期 docker 版本可安装也就先这么着吧。&lt;/p&gt;

&lt;p&gt;这个是在 &lt;a href=&#34;http://icyleaf.com/2013/09/how-to-install-gitlab-on-centos/&#34;&gt;如何在CentOS 上安装Gitlab&lt;/a&gt; 之后有一个无奈的使用指南，
因为运维也有他的考虑方面，参见知乎讨论：&lt;a href=&#34;https://www.zhihu.com/question/29191794&#34;&gt;如何说服运维选择 Debian/Ubuntu 而不是 CentOS&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装-docker&#34;&gt;安装 Docker&lt;/h2&gt;

&lt;h3 id=&#34;1-7-1&#34;&gt;1.7.1&lt;/h3&gt;

&lt;p&gt;Docker 最后一个支持 CentOS 6 的版本是 1.7.1 还必须安装 epel 源之后就&lt;a href=&#34;https://github.com/docker/docker/issues/14365&#34;&gt;被大家欢天喜地的抛弃了 6 的支持&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo rpm -ivh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
sudo yum -y remove docker
sudo yum install libselinux-python docker-io
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;由于 yum 内 docker 已经被其他使用，不用安装错误了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;1-7-1-以上版本&#34;&gt;1.7.1 以上版本&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;请果断放弃这种想法&lt;/strong&gt;，虽然你可能在网上搜索有个别的文章说把内核升级到 3.10 后可以安装 docker 1.9 版本，经过我个人反复测试根本不可行！&lt;/p&gt;

&lt;p&gt;当然如果你还是坚持想尝试，请参考如下链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pangxie.space/docker/364&#34;&gt;http://www.pangxie.space/docker/364&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/dongdongwq/p/5381752.html&#34;&gt;http://www.cnblogs.com/dongdongwq/p/5381752.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://0evin.com/2016/06/17/%5B%E5%8E%9F%E5%88%9B%5DCentOS6.5%E5%AE%89%E8%A3%85Docker1.11.X%E7%89%88%E6%9C%AC/&#34;&gt;http://0evin.com/2016/06/17/%5B%E5%8E%9F%E5%88%9B%5DCentOS6.5%E5%AE%89%E8%A3%85Docker1.11.X%E7%89%88%E6%9C%AC/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置-docker&#34;&gt;配置 Docker&lt;/h2&gt;

&lt;p&gt;安装成功后先不要配置开机自启动和启动服务，docker 的官方镜像在国内众所周知的慢的一塌糊涂，如果你是在国内服务器使用请参考如下配置。&lt;/p&gt;

&lt;p&gt;我这里把我个人私藏已久的好用的镜像告诉大家，大家可不要以为我用的是阿里云或者 DaoCloud 这类有很多限制的玩意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;中国科技大学镜像：&lt;a href=&#34;https://docker.mirrors.ustc.edu.cn&#34;&gt;https://docker.mirrors.ustc.edu.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;网易蜂巢镜像：&lt;a href=&#34;http://hub-mirror.c.163.com&#34;&gt;http://hub-mirror.c.163.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同样需要注意的是 1.7.1 版本的 docker 配置文件是在 &lt;code&gt;/etc/sysconfig/docker&lt;/code&gt; 而不是网上和官方说的 &lt;code&gt;/etc/default/docker&lt;/code&gt; 打开此文件在 other_args 配置对于的源即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# /etc/sysconfig/docker
#
# Other arguments to pass to the docker daemon process
# These will be parsed by the sysv initscript and appended
# to the arguments list passed to docker -d

#other_args=
#other_args=&amp;quot;--registry-mirror=http://hub-mirror.c.163.com&amp;quot;
other_args=&amp;quot;--registry-mirror=https://docker.mirrors.ustc.edu.cn&amp;quot;

DOCKER_CERT_PATH=/etc/docker

# Resolves: rhbz#1176302 (docker issue #407)
DOCKER_NOWARN_KERNEL_VERSION=1

# Location used for temporary files, such as those created by
# # docker load and build operations. Default is /var/lib/docker/tmp
# # Can be overriden by setting the following environment variable.
# # DOCKER_TMPDIR=/var/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后面就没什么好说的了，启动服务和设置开机自启动就完事了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo chkconfig docker on
sudo service docker start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证下启动的服务是否已经配置了国内镜像源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ps aux | grep &amp;quot;docker -d&amp;quot;

root     16992  0.1  0.1 1239860 32276 ?       Sl   Dec29   2:02 /usr/bin/docker -d --registry-mirror=https://docker.mirrors.ustc.edu.cn
root     26873  0.0  0.0 103332   876 pts/2    S+   18:16   0:00 grep docker -d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;疑难杂症&#34;&gt;疑难杂症&lt;/h2&gt;

&lt;h4 id=&#34;1-使用国内镜像源-pull-镜像偶尔会失败-反复几次就可以解决&#34;&gt;1. 使用国内镜像源 pull 镜像偶尔会失败，反复几次就可以解决&lt;/h4&gt;

&lt;p&gt;频次不高原因未知，因此还未重视。&lt;/p&gt;

&lt;h4 id=&#34;2-docker-web-管理工具&#34;&gt;2. Docker Web 管理工具&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;2018年10月更新：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;推荐使用 &lt;a href=&#34;https://github.com/portainer/portainer&#34;&gt;portainer&lt;/a&gt; ，兼容 1.7 的部分功能可能会发生部分功能和参数无法显示但不影响使用。之前我有推荐 rancher（可参考前篇文章：&lt;a href=&#34;http://icyleaf.com/2016/08/how-to-install-rancher-on-osx/&#34;&gt;如何在 OS X 上安装 Rancher
&lt;/a&gt;），但 rancher 官方要求 docker 最低版本是 1.9+。&lt;/p&gt;

&lt;h4 id=&#34;3-docker-进程挂了重启后无法恢复之前的-containers&#34;&gt;3. Docker 进程挂了重启后无法恢复之前的 containers&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker start c39206003c7a
Error: Cannot start container c39206003c7a: Error getting container c39206003c7ae8992a554a9ac2ea130327fc4af1b2c389656c34baf9a56c84b5 from driver devicemapper: Error mounting &#39;/dev/mapper/docker-253:0-267081-c39206003c7ae8992a554a9ac2ea130327fc4af1b2c389656c34baf9a56c84b5&#39; on &#39;/var/lib/docker/devicemapper/mnt/c39206003c7ae8992a554a9ac2ea130327fc4af1b2c389656c34baf9a56c84b5&#39;: device or resource busy
2014/05/08 19:14:57 Error: failed to start one or more containers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种一般是因为意外终止进程造成上次的 volume 没有正常 unmount，只需手动操作下即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;unmount /var/lib/docker/devicemapper/mnt/d640aea67108b04c6a5ba14645966b092db1f807f3e3f41dca7a1470f76b68fb
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;d640aea67108b04c6a5ba14645966b092db1f807f3e3f41dca7a1470f76b68fb&lt;/code&gt; 是根据不同 container 生成的，请根据实际情况复制和执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个真没办法，只能在 Dockerfile 或者进实例里面进行修改时区，这个我就不过多赘述了。&lt;/p&gt;

&lt;h4 id=&#34;4-升级运行的-container-版本&#34;&gt;4. 升级运行的 container 版本&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker stop xxxx
$ docker create --volumes-from &amp;lt;container_name_of_original_server&amp;gt; \ --name xxx-data image/name:&amp;lt;tag_of_previous_rancher_server&amp;gt;
$ docker pull image/name:latest
$ docker run -d --volumes-from xxx-data --restart=unless-stopped \ -p 8080:8080 image/namel.:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-非-root-用户执行-docker&#34;&gt;5. 非 root 用户执行 docker&lt;/h4&gt;

&lt;p&gt;创建 docker 用户组并重启 docker 服务，之后把你想要的用户加到 docker 用户组即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ groupadd docker
$ service docker restart
$ usermod -a -G docker icyleaf
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;6-宿主机-cst-时间会造成-docker-实例时间不准&#34;&gt;6. 宿主机 CST 时间会造成 docker 实例时间不准&lt;/h4&gt;

&lt;p&gt;这个真没办法，只能在 Dockerfile 或者进实例里面进行修改时区，这个我就不过多赘述了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何在 OS X 上安装 Rancher</title>
      <link>http://icyleaf.com/2016/08/how-to-install-rancher-on-osx</link>
      <pubDate>Fri, 05 Aug 2016 17:21:08 +0800</pubDate>
      
      <guid>http://icyleaf.com/2016/08/how-to-install-rancher-on-osx</guid>
      <description>

&lt;p&gt;Rancher 是 Docker 编排解决方案的一种，好处在于可以做容器编排，网络，存储，负载均衡，还能够支持云服务器（比如 Amazon EC2/Azure/DigitalOcean）也能够兼容 Docker Swarm/Mesos/Kubernetes 等其他的解决方案。自它还没有发布 &lt;a href=&#34;http://rancher.com/announcing-rancher-1-0-ga/&#34;&gt;1.0&lt;/a&gt; 版本之前也有持续的关注。它自身还有个 &lt;a href=&#34;http://www.infoq.com/cn/news/2015/03/rancheros-docker-linux&#34;&gt;RancherOS&lt;/a&gt; 对于 CoreOS 也是一个不小的威胁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://docs.rancher.com/img/rancher/rancher_overview_2.png&#34; alt=&#34;rancher-intro&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于它提供非常优化的后台管理界面，同时也提供 REST API，日常开发使用中异常的方便。如果非要说出一点不好的，那可能就是它对内存有点小要求：&lt;strong&gt;最小 1GB 内存&lt;/strong&gt;，因此如果想放在自己 VPS 上的童鞋需要评估下了。&lt;/p&gt;

&lt;h2 id=&#34;mac-安装&#34;&gt;Mac 安装&lt;/h2&gt;

&lt;p&gt;这块也趁着 &lt;a href=&#34;https://docs.docker.com/docker-for-mac/&#34;&gt;Docker for Mac&lt;/a&gt; 的好处，终于摆脱的 &lt;code&gt;docker-machine&lt;/code&gt; 的折磨，不用在依赖 VirtualBox，也不在每次装载 machine 的变量和查找虚拟机的 IP。映射的端口端口都通过 &lt;code&gt;localhost&lt;/code&gt; 访问。&lt;/p&gt;

&lt;p&gt;Rancher 通过 Docker 来安装本来说是非常简单的，它分为服务端和客户端。本教程以 &lt;a href=&#34;http://docs.rancher.com/rancher/latest/en/installing-rancher/installing-server/&#34;&gt;Single Node&lt;/a&gt; 来讲解，不考虑 &lt;a href=&#34;http://docs.rancher.com/rancher/latest/en/installing-rancher/installing-server/multi-nodes/&#34;&gt;Multi Node&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这块网上一直没有太好的解决方案，我看很多国外给出的&lt;a href=&#34;https://gist.github.com/axnux/09dc375d71398cbbee44ebd23ba35a08&#34;&gt;解决方案&lt;/a&gt;也比较麻烦，主要是由于 Docker for mac 使用的是 xhyve 作为轻量化的虚拟化方案，而 rancher 安装 server 端没有任何问题，在添加主机的时候需要通过 HTTP 来连接 server 端而失败。下面我来带大家用最简单的方案来拆解。无需任何第三方的辅助。&lt;/p&gt;

&lt;h3 id=&#34;服务端&#34;&gt;服务端&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;如果网速连接 docker hub 过慢可考虑使用代理设置或者国内的镜像服务，我这里分享一个 &lt;code&gt;https://docker.mirrors.ustc.edu.cn&lt;/code&gt;，可在 Docker -&amp;gt; Preferences&amp;hellip; -&amp;gt; Advanced -&amp;gt; Registry Mirror 添加。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -d --name rancher-server --restart=always -p 8080:8080 rancher/server
$ docker logs -f rancher-server

time=&amp;quot;2016-08-05T16:48:52Z&amp;quot; level=info msg=&amp;quot;Creating schema machine, roles [service]&amp;quot; id=1ds17
time=&amp;quot;2016-08-05T16:48:53Z&amp;quot; level=info msg=&amp;quot;Creating schema machine, roles [project member owner]&amp;quot; id=1ds18
time=&amp;quot;2016-08-05T16:48:53Z&amp;quot; level=info msg=&amp;quot;Creating schema machine, roles [admin user readAdmin]&amp;quot; id=1ds19
time=&amp;quot;2016-08-05T16:48:53Z&amp;quot; level=info msg=&amp;quot;Creating schema machine, roles [readonly]&amp;quot; id=1ds20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到如上类似的日志说明服务已经初始化完毕，通过浏览器访问 &lt;code&gt;http://localhost:8080&lt;/code&gt; 就可以看到后台管理界面。&lt;/p&gt;

&lt;h3 id=&#34;客户端&#34;&gt;客户端&lt;/h3&gt;

&lt;p&gt;先不着急继续页面操作，回到终端上执行如下命令获取 rancher-server 容器的 IP 地址备用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker inspect --format &#39;{{ .NetworkSettings.IPAddress }}&#39; rancher-server
172.17.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着上面的步骤，在打开页面能看到 Add Host 按钮并点击对于弹出 “Host Registration URL” 选择 “Something else:” 在后面的输入框填入上面的 IP 和端口号 &lt;code&gt;http://172.17.0.2:8080&lt;/code&gt; 并保存。&lt;/p&gt;

&lt;p&gt;之后就是给你一个客户端（部署主机）的选项，由于我们只添加本机作为部署主机使用，因此这里选择 Custom，其他不用任何设置，直接滑倒最底部找到一个执行 docker 命令的区域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/006tNbRwjw1f6jdkffiqhj31ee150k0c.jpg&#34; alt=&#34;add rancher host&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -d --privileged -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/rancher:/var/lib/rancher rancher/agent:v1.0.2 http://172.17.0.2:8080/v1/scripts/676576FFEC2212A68391:1470416400000:tfqxfdglHL6Qw8dpLVtbOesYY4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现执行可能会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker: Error response from daemon: Mounts denied:
The path /var/lib/rancher
is not shared from OS X and is not known to Docker.
You can configure shared paths from Docker -&amp;gt; Preferences... -&amp;gt; File Sharing.
See https://docs.docker.com/docker-for-mac/osxfs/#namespaces for more info.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前有可能是一个 Docker 的 Bug，因为 &lt;code&gt;/var/lib/rancher&lt;/code&gt; 是挂载到已经默认添加 &lt;code&gt;/private&lt;/code&gt; 文件共享，但是它还是报错，如果你在 Docker 设置的 File Sharing 添加的话它也不会让你添加，因此我们需要做一点小修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -d --privileged -v /var/run/docker.sock:/var/run/docker.sock -v ${HOME}/docker/rancher/var/lib/rancher:/var/lib/rancher rancher/agent:v1.0.2 http://172.17.0.2:8080/v1/scripts/676576FFEC2212A68391:1470416400000:tfqxfdglHL6Qw8dpLVtbOesYY4
5cf22a10cf28b4182b6e205fa631146e86d67c3c9d86901ff8cf7ab087319a29
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后点击页面的 Close 后会跳转到 Host 的列表，你就能惊喜的发现添加成功了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/006tNbRwjw1f6jdidcojkj315y0m4dik.jpg&#34; alt=&#34;rancher host&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;结尾&#34;&gt;结尾&lt;/h2&gt;

&lt;p&gt;本篇只先解决这一个问题，更多使用的资料请看&lt;a href=&#34;http://rancher.hidocker.io/&#34;&gt;Rancher 实战红宝书&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入浅出 Fastlane 一看你就懂</title>
      <link>http://icyleaf.com/2016/07/fastlane-in-action</link>
      <pubDate>Tue, 19 Jul 2016 20:12:07 +0800</pubDate>
      
      <guid>http://icyleaf.com/2016/07/fastlane-in-action</guid>
      <description>

&lt;p&gt;这是《 &lt;a href=&#34;https://icyleaf.com/2016/07/intro-fastlane-automation-for-ios-and-android/&#34;&gt;Fastlane - iOS 和 Android 的自动化构建工具&lt;/a&gt;》系列的第二篇。&lt;/p&gt;

&lt;p&gt;本篇我想着重介绍 &lt;code&gt;fastlane&lt;/code&gt; 本身的基本使用，这里使用 fastlane v1.98.0 作为演示版本。&lt;/p&gt;

&lt;h3 id=&#34;系列索引&#34;&gt;系列索引&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://icyleaf.com/2016/07/intro-fastlane-automation-for-ios-and-android/&#34;&gt;Fastlane - iOS 和 Android 的自动化构建工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://icyleaf.com/2016/07/fastlane-in-action/&#34;&gt;深入浅出 Fastlane 一看你就懂&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://icyleaf.com/2017/03/match-in-action/&#34;&gt;你虐我千百遍，我待你如初恋，直到我遇到 match&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;命令行工具&#34;&gt;命令行工具&lt;/h2&gt;

&lt;p&gt;安装之后默认会安装一个命令行工具 &lt;code&gt;fastlane&lt;/code&gt;，利用它可以初始化、执行任务、查看任务定义、查看可用的动作和动作的详细定义，甚至可以用它来创建自定义的动作、插件以及一些辅助功能。想了解的话可以先看看它的帮助：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fastlane --help

  fastlane

  CLI for &#39;fastlane&#39; - The easiest way to automate building and releasing your iOS and Android apps

        Run using `fastlane [platform] [lane_name]`
        To pass values to the lanes use `fastlane [platform] [lane_name] key:value key2:value2`

  Commands:
    action                  Shows more information for a specific command
    actions                 Lists all available fastlane actions
    add_plugin              Add a new plugin to your fastlane setup
    disable_crash_reporting Deprecated: fastlane doesn&#39;t use a crash reporter any more
    docs                    Generate a markdown based documentation based on the Fastfile
    enable_auto_complete    Enable tab auto completion
    enable_crash_reporting  Deprecated: fastlane doesn&#39;t use a crash reporter any more
    help                    Display global or [command] help documentation
    init                    Helps you with your initial fastlane setup
    install_plugins         Install all plugins for this project
    lanes                   Lists all available lanes and shows their description
    list                    Lists all available lanes without description
    new_action              Create a new custom action for fastlane.
    new_plugin              Create a new plugin that can be used with fastlane
    run                     Run a fastlane one-off action without a full lane
    search_plugins          Search for plugins, search query is optional
    trigger                 Run a sepcific lane. Pass the lane name and optionally the platform first.
    update_plugins          Update all plugin dependencies

  Global Options:
    --verbose
    -h, --help           Display help documentation
    -v, --version        Display version information

  Author:
    Felix Krause &amp;lt;fastlane@krausefx.com&amp;gt;

  Website:
    https://fastlane.tools

  GitHub:
    https://github.com/fastlane/fastlane
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我会随着下面每个概念的解释和展开来配合上面的命令一起讲解。&lt;/p&gt;

&lt;h2 id=&#34;生命周期&#34;&gt;生命周期&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;执行顺序&lt;/th&gt;
&lt;th&gt;方法名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;before_all&lt;/td&gt;
&lt;td&gt;在执行 lane 之前只执行一次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;before_each&lt;/td&gt;
&lt;td&gt;每次执行 lane 之前都会执行一次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;lane&lt;/td&gt;
&lt;td&gt;自定义的任务&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;after_each&lt;/td&gt;
&lt;td&gt;每次执行 lane 之后都会执行一次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;after_all&lt;/td&gt;
&lt;td&gt;在执行 lane 成功结束之后执行一次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;在执行上述情况任意环境报错都会中止并执行一次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上的部分大家在上一篇已经见识过了，有些还没接触到，不用着急都会一一说明。&lt;/p&gt;

&lt;h2 id=&#34;任务-lane&#34;&gt;任务（lane）&lt;/h2&gt;

&lt;p&gt;正常情况下你可能只会是用到一种任务方法 &lt;code&gt;lane&lt;/code&gt; 但其实它会包含很多中高级用法。在文章的末尾会详细描述。&lt;/p&gt;

&lt;h3 id=&#34;任务定义&#34;&gt;任务定义&lt;/h3&gt;

&lt;p&gt;定义任务的方法类似于 rake 的 task，但使用上缺比前者要好用很多，见下表：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;desc&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方法描述&lt;/td&gt;
&lt;td&gt;可多次使用打到换行的目的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方法名&lt;/td&gt;
&lt;td&gt;符号化的方法名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;options&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方法参数&lt;/td&gt;
&lt;td&gt;返回 Hash 类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;task&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方法主体&lt;/td&gt;
&lt;td&gt;参考 ruby 的方法代码且支持 ruby 代码&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;desc &#39;定义一个 build 方法&#39;
desc &#39;参数 adhoc 判断是否为内测版本, 默认为 false&#39;
desc &#39;fastlane build&#39;
desc &#39;fastlane build adhoc:true&#39;
lane :build do |options|
  # task to do something
  adhoc = options[:adhoc] || false
  puts &amp;quot;adhoc: #{adhoc}&amp;quot;

  gym(type: adhoc ? &#39;adhoc&#39; : &#39;appstore&#39;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;任务执行&#34;&gt;任务执行&lt;/h3&gt;

&lt;p&gt;一般情况下它需要配合定义好的 lane 才能使用，刚刚我们定义的一个 build 方法，我们这里就试着执行一下吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 默认执行
$ fastlane build
# 传递参数
$ fastlane build adhoc:true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;任务互调&#34;&gt;任务互调&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;lane&lt;/code&gt; 其实可以理解为 &lt;code&gt;def&lt;/code&gt; 的别名，因此多个 lane 的话实际上是可以相互调用的，这个其实特别实用，这样其实我就可以把 cocoapods 的执行放到单独的 lane 里面而不是 &lt;code&gt;before_all&lt;/code&gt;，这样执行非构建的任务就不会执行不相关的任务或动作，因此 fastlane 而产生了一个私有任务用内部使用 &lt;code&gt;private_lane&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;
default_platform :ios

platform :ios do
  desc &#39;构建前的准备工作&#39;
  desc &#39;这是一个私有任务，仅供 Fastfile 内部 lane 调用使用&#39;
  lane :prepare do
    cocoapods
    match
  end

  desc &#39;通用的构建任务&#39;
  desc &#39;fastlane build&#39;
  desc &#39;fastlane build type:adhoc&#39;
  lane :build do |options|
    # 调用上面 prepare 私有任务
    prepare

    case options[:type]
    when &#39;adhoc&#39;
      # 调用 下面 adhoc 任务
      adhoc
    else
      # 调用下面 appstore 任务
      appstore
    end
  end

  desc &#39;构建 adhoc 任务&#39;
  desc &#39;fastlane adhoc&#39;
  lane :adhoc do
    gym(type: &#39;adhoc&#39;)
  end

  desc &#39;构建 appstore 任务&#39;
  desc &#39;fastlane appstore&#39;
  lane :appstore do
    gym(type: &#39;appstore&#39;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的任务中，&lt;code&gt;build&lt;/code&gt;/&lt;code&gt;adhoc&lt;/code&gt;/&lt;code&gt;appstore&lt;/code&gt; 都可以执行，只有 &lt;code&gt;prepare&lt;/code&gt; 是无法通过命令行外部执行，如果执行会直接报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fastlane prepare
[19:17:42]: You can&#39;t call the private lane &#39;prepare&#39; directly
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;任务返回值&#34;&gt;任务返回值&lt;/h3&gt;

&lt;p&gt;和 ruby 的方法一致，每个 lane 最后一行会默认作为返回值（无需 &lt;a href=&#34;http://learnrubythehardway.org/book/ex21.html&#34;&gt;return&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;
lane :sum do |options|
  options[:a] + optiona[:b]
end

lane :calculate do
  value = sum(a: 3, b: 5)
  puts value #=&amp;gt; 8
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;引入外部任务文件&#34;&gt;引入外部任务文件&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Fastfile&lt;/code&gt; 除了自身以外还能够引入外部其他的 &lt;code&gt;Fastfile&lt;/code&gt; 并调用任务，只需要导入外部文件并使用特殊的方法标识即可：&lt;/p&gt;

&lt;h4 id=&#34;1-import-导入本地文件&#34;&gt;1. import - 导入本地文件&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 导入 lanes 目录的 AndroidFastfile
import &amp;quot;lanes/AndroidFastfile&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-import-from-git-导入-git-仓库文件&#34;&gt;2. import_from_git - 导入 git 仓库文件&lt;/h4&gt;

&lt;p&gt;可以直接引入 git 仓库的 Fastfile 文件是一个非常赞的功能，通过使用发现其实现原理是先把 git 仓库克隆下来后在引入相对于的文件，因此建议国内在没有网络加速（翻墙）的情况下尽量不用引入比较大的 git 仓库，否则使用会需要漫长的等待&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 导入 mozilla/firefox-ios 项目下 fastlane 下面 Fastfile 文件
import_from_git(url: &#39;https://github.com/mozilla/firefox-ios&#39;)
# 或者
import_from_git(url: &#39;git@github.com:mozilla/firefox-ios.git&#39;,
               path: &#39;fastlane/Fastfile&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假若外部引入的 &lt;code&gt;Fastfile&lt;/code&gt; 有个方法是 &lt;strong&gt;build&lt;/strong&gt;，在命令行工具直接执行即可，如果外部和内部都有相同的任务名，执行会直接报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fastlane ios build

[!] Lane &#39;gradle&#39; was defined multiple times!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果发生这样的事情且你希望在主体 &lt;code&gt;Fastfile&lt;/code&gt; 也调用的话需要使用特殊的方法定义：&lt;code&gt;override_lane&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：此方法只会覆盖外部的相同方法名的代码执行，目前暂时无法使用类似 ruby 的 &lt;code&gt;super&lt;/code&gt; 继承原由方法！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;override_lane :build do
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;任务查看&#34;&gt;任务查看&lt;/h3&gt;

&lt;p&gt;只需执行下面这行命令就可以看到非私有任务的可用列表信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fastlane lanes

--------- ios---------
----- fastlane ios build
通用的构建任务
fastlane build
fastlane build type:adhoc

----- fastlane ios adhoc
构建 adhoc 任务

----- fastlane ios appstore
构建 appstore 任务

Execute using `fastlane [lane_name]`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;扩展-action&#34;&gt;扩展（Action）&lt;/h2&gt;

&lt;p&gt;扩展是 fastlane 的杀手锏，重在集成了众多非常优秀好用的方法供 lane 内部使用，截至 fastlane v&lt;code&gt;1.98.0&lt;/code&gt; 版本以包含 175 个扩展，这个数量还在陆续增加中。扩展初期是由发起人一个人完成，后续的大部分都是社区共享，如果你发现没有你想要的扩展，可以先去 &lt;a href=&#34;https://github.com/fastlane/fastlane/issues?q=is%3Aopen+is%3Aissue+label%3Aaction&#34;&gt;issues&lt;/a&gt; 搜索下没有要么自己动手提交要么只有等待了.&lt;/p&gt;

&lt;h3 id=&#34;扩展列表&#34;&gt;扩展列表&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fastlane actions
+--------------------+-------------------------------------------------------------+------------------+
|                                   Available fastlane actions                                        |
+--------------------+-------------------------------------------------------------+------------------+
| Action             | Description                                                 | Author           |
+--------------------+-------------------------------------------------------------+------------------+
| adb                | Run ADB Actions                                             | hjanuschka       |
| adb_devices        | Get an Array of Connected android device serials            | hjanuschka       |
| add_git_tag        | This will add an annotated git tag to the current branch    | Multiple         |
...
+--------------------+-------------------------------------------------------------+------------------+
  Total of 175 actions

Get more information for one specific action using `fastlane action [name]`
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;扩展使用帮助&#34;&gt;扩展使用帮助&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 查看 adb 扩展的使用帮助
$ fastlane action adb
Loading documentation for adb:

+---------------------------------+
|               adb               |
+---------------------------------+
| Run ADB Actions                 |
|                                 |
| see adb --help for more details |
|                                 |
| Created by hjanuschka           |
+---------------------------------+

+----------+----------------------------------------------------------------------+-------------------+---------+
|                                                  adb Options                                                  |
+----------+----------------------------------------------------------------------+-------------------+---------+
| Key      | Description                                                          | Env Var           | Default |
+----------+----------------------------------------------------------------------+-------------------+---------+
| serial   | Android serial, which device should be used for this command         | FL_ANDROID_SERIAL |         |
| command  | All commands you want to pass to the adb command, e.g. `kill-server` | FL_ADB_COMMAND    |         |
| adb_path | The path to your `adb` binary                                        | FL_ADB_PATH       | adb     |
+----------+----------------------------------------------------------------------+-------------------+---------+

+-------------------------------+
|       adb Return Value        |
+-------------------------------+
| The output of the adb command |
+-------------------------------+

More information can be found on https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建自定义扩展&#34;&gt;创建自定义扩展&lt;/h3&gt;

&lt;p&gt;通过内置的命令创建你需要的扩展，扩展名必须是全部小写且只能使用下划线分割词组，生成好的扩展文件会在 &lt;code&gt;fastlane/actions&lt;/code&gt; 目录找到:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fastlane new_action
Must be lower case, and use a &#39;_&#39; between words. Do not use &#39;.&#39;
examples: &#39;testflight&#39;, &#39;upload_to_s3&#39;
Name of your action: hello
[15:33:15]: Created new action file &#39;./fastlane/actions/hello.rb&#39;. Edit it to implement your custom action.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这块会占比较大的篇幅，尽情期待后续的展开。&lt;/p&gt;

&lt;h3 id=&#34;引入外部扩展&#34;&gt;引入外部扩展&lt;/h3&gt;

&lt;p&gt;这块其实也有两种方法可以引入，文件引入是官方教程提供的方法，第二种是我个人尝试出来的，第三种是最近版本才官方支持的。&lt;/p&gt;

&lt;h4 id=&#34;1-本地文件引入&#34;&gt;1. 本地文件引入&lt;/h4&gt;

&lt;p&gt;自定义的扩展其实也算是本地文件引入的一种形式，当然位于其他路径的通过指定方法也能做到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 引入项目根目录 script/share_actions 路径
actions_path &#39;../script/share_actions&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-rubygem-引入&#34;&gt;2. rubygem 引入&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;不再建议使用本方法，请看第三种插件引入。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在团队内部创建了一个自定义的扩展，仅限于团队内部使用而无法贡献社区，我只能采取封装成 ruby gem 包，通过 ruby 的 &lt;code&gt;require&lt;/code&gt; 方式引入，最终可以完美支持，目前已在项目中使用大半年之久。最重要的是我是开源的：&lt;a href=&#34;https://github.com/icyleaf/fastlane-qyer&#34;&gt;fastlane-qyer&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 首先安装需要的 rubygem: gem install fastlane-qyer
require &#39;fastlane-qyer&#39;

lane :upload do
  qyer(api_key: &#39;[token]&#39;)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，使用 rubygem 引入的无法在 fastlane actions 中显示出来，也无法使用 fastlane action [name] 查看使用帮助。我猜想一是官方没有这样提供思路，二是就算你引入了 gem 也不是特别好判断里面的文件结构。&lt;/p&gt;

&lt;h4 id=&#34;3-插件引入&#34;&gt;3. 插件引入&lt;/h4&gt;

&lt;p&gt;我注意到 &lt;a href=&#34;https://github.com/fastlane/fastlane/releases/tag/1.93.0&#34;&gt;1.93.0&lt;/a&gt; 增加了插件机制，很好的解决第二种出现的一些问题。大概看了一下主要是采用 &lt;code&gt;Gemfile&lt;/code&gt; 的方式使用 &lt;code&gt;Pluginfile&lt;/code&gt; 维护了引入第三方插件列表。实现原理还是属于第二种方法。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;fastlane search_plugins&lt;/code&gt; 查看当前支持的插件，并使用 &lt;code&gt;fastlane add_plugins [name]&lt;/code&gt; 引入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fastlane search_plugins
[16:04:33]: Listing all available fastlane plugins

+--------------------------+---------------------------------------------------+-----------+
|                                Available fastlane plugins                                |
+--------------------------+---------------------------------------------------+-----------+
| Name                     | Description                                       | Downloads |
+--------------------------+---------------------------------------------------+-----------+
| ruby                     | Useful fastlane actions for Ruby projects         | 782       |
| versioning               | Allows to work set/get app version directly       | 758       |
|                          | to/from Info.plist                                |           |
| branding                 | Add some branding to your fastlane output         | 716       |
| instrumented_tests       | New action to run instrumented tests for android. | 590       |
|                          | This basically creates and boots an emulator      |           |
|                          | before running an gradle commands so that you can |           |
|                          | run instrumented tests against that emulator.     |           |
|                          | After the gradle command is executed, the avd     |           |
|                          | gets shut down and deleted. This is really        |           |
|                          | helpful on CI services, keeping them clean and    |           |
|                          | always having a fresh avd for testing.            |           |
| xamarin_build            | Build xamarin android\ios projects                | 582       |
| appicon                  | Generate required icon sizes and iconset from a   | 509       |
|                          | master application icon.                          |           |
...
| download_file            | This action downloads a file from an HTTP/HTTPS   | 171       |
|                          | url (e.g. ZIP file) and puts it in a destination  |           |
|                          | path                                              |           |
+--------------------------+---------------------------------------------------+-----------+

# 添加 sentry 插件
$ fastlane add_plugin sentry
[16:16:23]: Plugin &#39;fastlane-plugin-sentry&#39; was added to &#39;./fastlane/Pluginfile&#39;
[16:16:23]: It looks like fastlane plugins are not yet set up for this project.
[16:16:23]: fastlane will create a new Gemfile at path &#39;Gemfile&#39;
[16:16:23]: This change is neccessary for fastlane plugins to work
Should fastlane modify the Gemfile at path &#39;Gemfile&#39; for you? (y/n)
y
[16:16:29]: Successfully modified &#39;Gemfile&#39;
[16:16:29]: Make sure to commit your Gemfile, Gemfile.lock and Pluginfile to version control
Installing plugin dependencies...
Successfully installed plugins

$ cat fastlane/Pluginfile
# Autogenerated by fastlane
#
# Ensure this file is checked in to source control!

gem &#39;fastlane-plugin-sentry&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更详细的继续期待后续报道，我要挖坑无数。&lt;/p&gt;

&lt;h3 id=&#34;扩展的命令行调用&#34;&gt;扩展的命令行调用&lt;/h3&gt;

&lt;p&gt;社区的力量果然是很强大的，陆续添加了那么多功能，早期用户表示不开心！嗯，由于社区的呼声和贡献目前可以通过命令调用扩展：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 使用 notification 扩展发送一个通知消息
$ fastlane run notification message:&amp;quot;Hi macOS&amp;quot; title:&amp;quot;Fastlane Notification&amp;quot;
[15:58:05]: --------------------------
[15:58:05]: --- Step: notification ---
[15:58:05]: --------------------------
[15:58:05]: Result: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;辅助功能&#34;&gt;辅助功能&lt;/h2&gt;

&lt;h3 id=&#34;自动更新&#34;&gt;自动更新&lt;/h3&gt;

&lt;p&gt;fastlane 提供一个方法 &lt;code&gt;update_fastlane&lt;/code&gt; 用于对于自身的版本检查和更新，这个第一篇文章我也有提到过。它其实一个是一个扩展，使用 &lt;code&gt;fastlane action update_fastlane&lt;/code&gt; 能够看到使用帮助。它有一个参数是可以指定检查特定的 fastlane 工具并进行更新，但其实它是使用 rubygems 进行对 gem 的更新，因此这块其实可以传入任何需要检查并更新的 gem：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;update_fastlane(tools:&#39;fastlane,gym,match,cocoapods,rest-client&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;环境变量&#34;&gt;环境变量&lt;/h3&gt;

&lt;p&gt;从 fastlane 的设计体系上在各个地方都加入了环境变量的支持，每个扩展的参数、以及扩展需要共享给其他扩展和任务读取的数据都是通过环境变量获取，如下是我收集的比较常用的列表：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;环境变量&lt;/th&gt;
&lt;th&gt;来源&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FASTLANE_USER&lt;/td&gt;
&lt;td&gt;credentials_manager&lt;/td&gt;
&lt;td&gt;Apple 开发者账户名&lt;/td&gt;
&lt;td&gt;验证通过后会保存 Keychain&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FASTLANE_PASSWORD&lt;/td&gt;
&lt;td&gt;credentials_manager&lt;/td&gt;
&lt;td&gt;Apple 开发者账户密码&lt;/td&gt;
&lt;td&gt;验证通过后会保存 Keychain&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FASTLANE_TEAM_ID&lt;br /&gt;CERT_TEAM_ID&lt;/td&gt;
&lt;td&gt;produce&lt;br /&gt;sigh&lt;/td&gt;
&lt;td&gt;Apple 团队 ID&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DELIVER_USER&lt;br \&gt;PRODUCE_USERNAME&lt;/td&gt;
&lt;td&gt;deliver&lt;br /&gt;produce&lt;/td&gt;
&lt;td&gt;iTunesConnect 账户名&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DELIVER_PASSWORD&lt;/td&gt;
&lt;td&gt;deliver&lt;/td&gt;
&lt;td&gt;iTunesConnect 账户密码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MATCH_PASSWORD&lt;/td&gt;
&lt;td&gt;match&lt;/td&gt;
&lt;td&gt;证书加/解密密码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FASTLANE_XCODE_LIST_TIMEOUT&lt;/td&gt;
&lt;td&gt;fastlane_core&lt;/td&gt;
&lt;td&gt;获取 iOS Scheme 的超时时间&lt;/td&gt;
&lt;td&gt;默认 10s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Gitlab API Wrapper for Crystal</title>
      <link>http://icyleaf.com/2016/07/gitlab-api-wrapper-for-crystal</link>
      <pubDate>Mon, 11 Jul 2016 20:41:26 +0800</pubDate>
      
      <guid>http://icyleaf.com/2016/07/gitlab-api-wrapper-for-crystal</guid>
      <description>

&lt;h2 id=&#34;gitlab-cr&#34;&gt;Gitlab.cr&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/icyleaf/gitlab.cr&#34;&gt;gitlab.cr&lt;/a&gt; 是我最近课下练习的新语言 &lt;a href=&#34;http://crystal-lang.org/&#34;&gt;Crystal&lt;/a&gt; 写的 gitlab 包，方法和功能和 &lt;a href=&#34;https://github.com/NARKOZ/gitlab&#34;&gt;gitlab ruby 版本&lt;/a&gt;基本类似。&lt;/p&gt;

&lt;p&gt;目前已经完成了大部分 API 的封装，在一边熟悉 crystal 的同时一边补充，其中肯定有一些性能问题和坑，毕竟没有任何依赖都是自己实现的。比较坑爹的是官方手册太简单，也没有实时跟进，能够好好翻阅的其实也就是官方的 API 文档和源码。不过 crystal 还算比较人性化的一面，默认集成了类似 rspce 的单元测试（简化版）和依赖库管理 shards（类似 bundler）和生成文档的工具。通过 &lt;a href=&#34;https://travis-ci.org/``&#34;&gt;travis-ci&lt;/a&gt; 会自动生成每次 git push 的变化。&lt;/p&gt;

&lt;p&gt;API 文档：&lt;a href=&#34;http://icyleaf.github.io/gitlab.cr/&#34;&gt;http://icyleaf.github.io/gitlab.cr/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;为什么学习-crystal&#34;&gt;为什么学习 Crystal？&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/209371/13291809/022e2360-daf8-11e5-8be7-d02c1c8b38fb.png&#34; alt=&#34;crystal logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ruby 的缺点众所周知的一个点就是慢，虽说用它的人都不在乎主要是用的爽，so what！这一致命的坑其实默默的被承受着，很多的 Ruby 开发者也在一直寻觅着新的更高性能的语言。比如 Gitlab 的 Build Runner 使用 Go 实现了。Rails 的核心开发者基于多年对 Ruby 的怨念而开发的 Elixir，还有 Firefox 主导的 Rust 也吸引了不少目光。有那么多选择为什么偏偏选了这么一个没有听说过的语言？&lt;/p&gt;

&lt;h2 id=&#34;语言优势&#34;&gt;语言优势&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;类似 Ruby 风格语法（但舍弃了一些动态特性）&lt;/li&gt;
&lt;li&gt;一切都是对象（和 Ruby 一样）&lt;/li&gt;
&lt;li&gt;自动类型推荐和静态类型检查&lt;/li&gt;
&lt;li&gt;支持方法重载&lt;/li&gt;
&lt;li&gt;易用的 C 语言库的绑定机制&lt;/li&gt;
&lt;li&gt;基于 LLVM（目前不支持 Windows）&lt;/li&gt;
&lt;li&gt;编译性语言，可以打包二进制包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;仅仅是这些可能大家觉得没什么，其实对我来说也不够冲击力，最重要的关键是在我从订阅的 Ruby Weekly 周刊看到 sidekiq 的作者用 crystal 重新实现了核心部分发的&lt;a href=&#34;http://www.mikeperham.com/2016/05/25/sidekiq-for-crystal/&#34;&gt;博文分享&lt;/a&gt;，提到的一点：&lt;strong&gt;至少是比 ruby 2.3 大部分代码要快 3-5 倍，减少至少 3 倍的内存占用&lt;/strong&gt;。怀着怀疑的态度我大概的研究了这个语言，确实看到了新希望。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;库&lt;/th&gt;
&lt;th&gt;语言&lt;/th&gt;
&lt;th&gt;并发量&lt;/th&gt;
&lt;th&gt;平均响应时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/sdogruyol/fast-http-server&#34;&gt;fast-http-server&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Crystal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;18348.47rpm&lt;/td&gt;
&lt;td&gt;8.67ms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/indexzero/http-server&#34;&gt;http-server&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Node.js&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2105.55rpm&lt;/td&gt;
&lt;td&gt;47.92ms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.python.org/2/library/simplehttpserver.html&#34;&gt;SimpleHTTPServer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Python&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;785.14rpm&lt;/td&gt;
&lt;td&gt;1.91ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;还有一份一直再更新维护的语言之间的&lt;a href=&#34;https://github.com/kostya/benchmarks&#34;&gt;评测&lt;/a&gt;仅供参考，看着里面的数据还是蛮吸引人的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;评测数据来源: &lt;a href=&#34;http://www.akitaonrails.com/2016/05/31/flirting-with-crystal-a-rubyist-perspective&#34;&gt;Flirting with Crystal, a Rubyist Perspective&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;语言友好&#34;&gt;语言友好&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# File: server.cr
require &amp;quot;http/server&amp;quot;

server = HTTP::Server.new(8080) do |context|
  context.response.content_type = &amp;quot;text/plain&amp;quot;
  context.response.print &amp;quot;Hello world! The time is #{Time.now}&amp;quot;
end

puts &amp;quot;Listening on http://0.0.0.0:8080&amp;quot;
server.listen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看着是不是是不是和 Ruby 差不多。通过命令编译成二进制在运行试试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ crystal build --release server.cr
$ ./server
Listening on http://0.0.0.0:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;macOS 用户可以通过 brew 进行安装 &lt;code&gt;brew install crystal-lang&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;语言限制&#34;&gt;语言限制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;没有了强大的黑魔法，尤其是针对 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;send&lt;/code&gt; 两个的缺失。提供了 macro 的方式可以实现部分动态定义方法的机制。&lt;/li&gt;
&lt;li&gt;require 引入必须放置在头部（crystal 0.7.7 以上版本的限制）&lt;/li&gt;
&lt;li&gt;有待优化的 gc 机制（目前采用的是 &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B2%9D%E5%A7%86%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8&#34;&gt;Hans Boehm GC&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;还在开发中的语言，API 变化很快&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;最后想说的话&#34;&gt;最后想说的话&lt;/h2&gt;

&lt;p&gt;总体来说是一个让人眼前一亮的语言，很是期待后续的进化。我相信 sidekiq 作者的那篇博文也让无数开发者看到了新大陆。目前项目也在&lt;a href=&#34;https://salt.bountysource.com/teams/crystal-lang&#34;&gt;捐献&lt;/a&gt;中，如果你对它感兴趣不妨慷慨的动动自己的钱包，Ruby 的创始人 matz 直接捐献了 $500。&lt;/p&gt;

&lt;h2 id=&#34;相关资源&#34;&gt;相关资源&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;作者 Twitter: &lt;a href=&#34;https://twitter.com/asterite&#34;&gt;https://twitter.com/asterite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Awesome Crystal: &lt;a href=&#34;http://awesome-crystal.com/&#34;&gt;http://awesome-crystal.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sidekiq for Crystal: &lt;a href=&#34;http://www.mikeperham.com/2016/05/25/sidekiq-for-crystal/&#34;&gt;http://www.mikeperham.com/2016/05/25/sidekiq-for-crystal/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Test Driving Sidekiq and Crystal: &lt;a href=&#34;http://www.mikeperham.com/2016/06/14/test-driving-sidekiq-and-crystal/&#34;&gt;http://www.mikeperham.com/2016/06/14/test-driving-sidekiq-and-crystal/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Flirting with Crystal, a Rubyist Perspective: &lt;a href=&#34;http://www.akitaonrails.com/2016/05/31/flirting-with-crystal-a-rubyist-perspective&#34;&gt;http://www.akitaonrails.com/2016/05/31/flirting-with-crystal-a-rubyist-perspective&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Fastlane - iOS 和 Android 的自动化构建工具</title>
      <link>http://icyleaf.com/2016/07/intro-fastlane-automation-for-ios-and-android</link>
      <pubDate>Mon, 11 Jul 2016 12:36:07 +0800</pubDate>
      
      <guid>http://icyleaf.com/2016/07/intro-fastlane-automation-for-ios-and-android</guid>
      <description>

&lt;h3 id=&#34;系列索引&#34;&gt;系列索引&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://icyleaf.com/2016/07/intro-fastlane-automation-for-ios-and-android/&#34;&gt;Fastlane - iOS 和 Android 的自动化构建工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://icyleaf.com/2016/07/fastlane-in-action/&#34;&gt;深入浅出 Fastlane 一看你就懂&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://icyleaf.com/2017/03/match-in-action/&#34;&gt;你虐我千百遍，我待你如初恋，直到我遇到 match&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这篇文章整理了很久，发现在一篇文章里无法一一讲述和全面的覆盖，初步打算是把这个做成一个系列，想到哪里就写到哪里，如果恰好有读者爱戴并有一些建议反馈，我也会根据大家的需要调整内容的方向和深度。论美剧的编剧的重要性(笑)。&lt;/p&gt;

&lt;h2 id=&#34;初次邂逅&#34;&gt;初次邂逅&lt;/h2&gt;

&lt;p&gt;初时 fastlane 的时候是去年的 11 月份，看到大就感觉遇到了神器一般的惊喜。它一个针对于 iOS 和 Android（后来才支持的）全方位自动化流程的工具，请看下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fastlane.tools/assets/img/intro-fastlane-tree.png&#34; alt=&#34;fastlane-flow&#34; /&gt;&lt;/p&gt;

&lt;p&gt;流程图中每个环节都是独立的工具，每个工具只干一件事情，分工非常的明确。以下是我在团队项目中用到的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fastlane/fastlane/tree/master/scan&#34;&gt;scan&lt;/a&gt; 自动化测试工具，很好的封装了 Unit Test&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fastlane/fastlane/tree/master/sigh&#34;&gt;sigh&lt;/a&gt; 针对于 iOS 项目开发证书和 Provision file 的下载工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fastlane/fastlane/tree/master/match&#34;&gt;match&lt;/a&gt; 同步团队每个人的证书和 Provision file 的超赞工具，规范&lt;a href=&#34;https://codesigning.guide/&#34;&gt;代码签名&lt;/a&gt;（虽然里面有些设定比较损）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fastlane/fastlane/tree/master/gym&#34;&gt;gym&lt;/a&gt; 针对于 iOS 打包和签名的自动化工具，完爆 &lt;code&gt;xctool&lt;/code&gt;，而 &lt;code&gt;shenzhen&lt;/code&gt; 也放弃维护&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/icyleaf/fastlane-qyer&#34;&gt;qyer&lt;/a&gt; 团队定制的工具，用于检测包和上传到自己的内部分发平台&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/fastlane/fastlane&#34;&gt;fastlane&lt;/a&gt; 简单理解就是控制整体流程和实现的框架容器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;利用目前支持的工具可以做所有包含自动化和可持续化构建的每个环节，比如单元测试、截图、分发渠道、上传元数据和 ipa 包提交审核等等。看到这这些是不是很兴奋？
反正我看到之后就像黑夜看到了光明，果断抛弃自己维护的脚本。&lt;/p&gt;

&lt;h2 id=&#34;基本构成&#34;&gt;基本构成&lt;/h2&gt;

&lt;p&gt;Fastlane 提供的流程的众多工具都是可以独立存在和使用（提供 cli 命令），也可以统一由 fastlane 来控制。它在使用中提出了两个概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;action&lt;/code&gt;: Fastlane 的插件，截至当前内置 165 个至多，不过每个动作的颗粒度大小不一。&lt;a href=&#34;https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md&#34;&gt;查看详情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lane&lt;/code&gt;: Fastlane 的任务（或者可以理解为命令），一个可以包含多个 lanes，通过 &lt;code&gt;fastlane&lt;/code&gt; cli 传入制定的 lane 来执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;光说不干假把式，看法宝：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;lane :adhoc do
  # build version 自动加一
  increment_build_number
  # 执行 pod install
  cocoapods
  # 调用 facebook 的 xctool 进行单元测试
  xctool
  # 对模拟器运行的 App 进行截图
  snapshot
  # 安装团队证书和 profiles
  match
  # 上传 App 元数据和签名的 ipa 到 iTunes Conneects
  deliver
  # 把截图套进一个设备外壳
  frameit
  # 允许自定义的脚本文件
  sh &amp;quot;./customScript.sh&amp;quot;
  # 发消息到 slack
  slack
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;工具的起源本身是专门针对 iOS 项目，因此目前依赖于 macOS 10.9 以上系统，Ruby 是一个众所周知的轮子发明者，很多知名的工具都是它开发的，fastlane 也不例外。以下是依赖环境：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;macOS 10.9+&lt;/li&gt;
&lt;li&gt;Ruby 2.0+ (推荐 rvm 或 rbenv 安装)&lt;/li&gt;
&lt;li&gt;Xcode + command line tools&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上依赖配置好之后就可以通过 rubygem 进行安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ [sudo] gem install fastlane
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fastlane 默认会把核心工具都会进行安装，需要大家耐心等待一会&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;

&lt;p&gt;有两种方法可以初始化，一种是通过命令，一种是自己创建指定的（至少包含一个）约束文件 &lt;code&gt;Fastfile&lt;/code&gt;。首先我先介绍大家使用命令初始化:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 切换只你开发的 iOS 项目根目录
$ cd to/your/ios/project
$ fastlane init
[11:46:34]: Detected iOS/Mac project in current directory...
[11:46:34]: This setup will help you get up and running in no time.
[11:46:34]: fastlane will check what tools you&#39;re already using and set up
[11:46:34]: the tool automatically for you. Have fun!
[11:46:34]: Created new folder &#39;./fastlane&#39;.
...
Your Apple ID (e.g. fastlane@krausefx.com): xxx@gmail.com
[11:46:59]: Verifying if app is available on the Apple Developer Portal and iTunes Connect...
[11:46:59]: Starting login with user &#39;xxx@gmail.com&#39;
Multiple teams found on the Developer Portal, please enter the number of the team you want to use:
1) XXXXXXXXXX &amp;quot;XXXXXXXXXX&amp;quot; (In-House)
2) YYYYYYYYYY &amp;quot;YYYYYYYYYY&amp;quot; (Company/Organization)
+----------------+----------------------------------------------------------------------------+
|                                       Detected Values                                       |
+----------------+----------------------------------------------------------------------------+
| Apple ID       | xxx@gmail.com                                                              |
| App Name       | Hello Fastlane                                                             |
| App Identifier | com.icyleaf.demo.HelloFastlane                                             |
| Workspace      | /Users/icyleaf/Development/iOS/HelloFastlane.xcworkspace                   |
+----------------+----------------------------------------------------------------------------+

[11:48:36]: This app identifier doesn&#39;t exist on iTunes Connect yet, it will be created for you
Please confirm the above values (y/n) n
App Identifier (com.krausefx.app): com.icyleaf.demo.HelloFastlane
[11:50:04]: Created new file &#39;./fastlane/Appfile&#39;. Edit it to manage your preferred app metadata information.
Optional: The scheme name of your app (If you don&#39;t need one, just hit Enter): AppDemo
[11:50:40]: &#39;snapshot&#39; not enabled.
[11:50:40]: &#39;cocoapods&#39; enabled.
[11:50:40]: &#39;carthage&#39; not enabled.
[11:50:40]: Created new file &#39;./fastlane/Fastfile&#39;. Edit it to manage your own deployment lanes.
[11:50:40]: fastlane will send the number of errors for each action to
[11:50:40]: https://github.com/fastlane/enhancer to detect integration issues
[11:50:40]: No sensitive/private information will be uploaded
[11:50:40]: Successfully finished setting up fastlane
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这部分会进行联网，并提示输入你的 Apple ID 来验证你的应用是否存在（没有也会帮你自动创建）并获取相应的关键信息，通过一系列的流程下来把获取的信息会创建一个 &lt;code&gt;fastlane&lt;/code&gt; 目录
并并写入相应的文件（如果某些信息没有填写会忽略某些文件的生成）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fastfile&lt;/code&gt;: 核心文件，主要用于 cli 调用和处理具体的流程，&lt;a href=&#34;https://github.com/fastlane/fastlane/tree/master/fastlane/docs#fastfile&#34;&gt;了解详情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Appfile&lt;/code&gt;: 从 Apple Developer Portal 获取和项目相关的信息，&lt;a href=&#34;https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Appfile.md&#34;&gt;了解详情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Deliverfile&lt;/code&gt;: 从 iTunes Connect 获取和项目相关的信息，&lt;a href=&#34;https://github.com/fastlane/fastlane/blob/master/deliver/Deliverfile.md&#34;&gt;了解详情&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;抛开其他的几个文件先不说，大家先把注意力放到刚创建好的 &lt;code&gt;Fastfile&lt;/code&gt; 文件上面（可能有变化，仅作参考），如果大家对 Ruby 有了解的话，它定义的 DSL 语言非常类似 &lt;a href=&#34;https://github.com/ruby/rake&#34;&gt;rake&lt;/a&gt;，但流程上有参考的 &lt;a href=&#34;https://github.com/rspec/rspec&#34;&gt;rspec&lt;/a&gt;，一旦不满足需求还可以使用 Ruby 代码来实现。单凭 DSL 语言来说就算对于 Ruby 没有基础的也能很快掌握，大多都是比较简单易懂的语法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Customise this file, documentation can be found here:
# https://github.com/fastlane/fastlane/tree/master/fastlane/docs
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version &amp;quot;1.95.0&amp;quot;

default_platform :ios

platform :ios do
  # 执行所有命令前都会先执行这里
  before_all do
    # ENV[&amp;quot;SLACK_URL&amp;quot;] = &amp;quot;https://hooks.slack.com/services/...&amp;quot;
    cocoapods
  end

  desc &amp;quot;Runs all the tests&amp;quot;
  lane :test do
    scan
  end

  desc &amp;quot;Submit a new Beta Build to Apple TestFlight&amp;quot;
  desc &amp;quot;This will also make sure the profile is up to date&amp;quot;
  lane :beta do
    # match(type: &amp;quot;appstore&amp;quot;) # more information: https://codesigning.guide
    gym(scheme: &amp;quot;AppDemo&amp;quot;) # Build your app - more options available
    pilot

    # sh &amp;quot;your_script.sh&amp;quot;
    # You can also use other beta testing services here (run `fastlane actions`)
  end

  desc &amp;quot;Deploy a new version to the App Store&amp;quot;
  lane :appstore do
    # match(type: &amp;quot;appstore&amp;quot;)
    # snapshot
    gym(scheme: &amp;quot;AppDemo&amp;quot;) # Build your app - more options available
    deliver(force: true)
    # frameit
  end

  # 你可以定义属于自己的 lane（任务）
  lane :hello do
    puts &amp;quot;hello world&amp;quot;
  end

  # 仅当上述流程全部执行成功后才会走这里。其实应该定义为 after_success
  after_all do |lane|
    # slack(
    #   message: &amp;quot;Successfully deployed new App Update.&amp;quot;
    # )
  end

  # 如果流程发生异常会走这里并终止
  error do |lane, exception|
    # slack(
    #   message: exception.message,
    #   success: false
    # )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的注解，我想大家对它已经有了初步的了解，那么定义完之后该如何执行呢？回到刚才的终端（关闭了？那再切换到刚才的 iOS 项目的根目录）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ fastlane ios hello
[11:56:24]: -------------------------------------------------
[11:56:24]: --- Step: Verifying required fastlane version ---
[11:56:24]: -------------------------------------------------
[11:56:24]: fastlane version valid
[11:56:24]: ------------------------------
[11:56:24]: --- Step: default_platform ---
[11:56:24]: ------------------------------
[11:56:24]: Driving the lane &#39;ios hello&#39; 🚀
[11:56:24]: -----------------------
[11:56:24]: --- Step: cocoapods ---
[11:56:24]: -----------------------
[11:56:24]: $ pod install
...
[11:56:28]: hello world

+------+-------------------------------------+-------------+
|                     fastlane summary                     |
+------+-------------------------------------+-------------+
| Step | Action                              | Time (in s) |
+------+-------------------------------------+-------------+
| 1    | Verifying required fastlane version | 0           |
| 2    | default_platform                    | 0           |
| 3    | cocoapods                           | 4           |
+------+-------------------------------------+-------------+

[11:56:28]: fastlane.tools finished successfully 🎉
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哒哒！一个简单的任务执行完毕！&lt;/p&gt;

&lt;p&gt;如果大家注意观察上面的文件可能注意到一些小细节：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 自动更新 fastlane 工具，需要 rubygems &amp;gt;= 2.1.0
update_fastlane

# 最低兼容版本，由于 fastlane 还是逐步健壮的阶段更新速度还是蛮快的，
# 为了防止新特性在旧版本的不支持会强制设置一个最低兼容版本
# 不过工具特别贴心的会在每次执行之后会检查是否有新版本，如果有会在最后末尾追加新版本提醒
fastlane_version &amp;quot;1.95.0&amp;quot;

# 默认使用平台是 ios，也就是说文件可以定义多个平台，
# 通过上述执行的命令也能看出来是执行的 ios 平台下面的 hello 任务。
# 这个的作用是可以在执行 fastlane 的时候省略 ios，不信你执行 fastlane hello 试试。
default_platform :ios
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;android-的支持&#34;&gt;Android 的支持&lt;/h2&gt;

&lt;p&gt;这个的支持我觉得关键是社区的呼声太大，加上贡献者的热情（我提交过许多 issues 和个别 PL，响应非常的迅速）很快就加上了其支持，
但具体的特性不是特别多，主要是对于 &lt;code&gt;gradle&lt;/code&gt; 的封装，我先不做展开介绍，大家可以先看看&lt;a href=&#34;https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Android.md&#34;&gt;官方文档&lt;/a&gt;，如果后续有特别不明白的地方我在做具体的讲解。&lt;/p&gt;

&lt;p&gt;今天就先写到这里后续我会继续整理更多的使用指南和实战范例共大家参考，最后给大家附赠官方给大家的一些&lt;a href=&#34;https://github.com/fastlane/examples&#34;&gt;范例&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hexo 主题推荐 NexT</title>
      <link>http://icyleaf.com/2015/12/hexo-theme-next</link>
      <pubDate>Thu, 17 Dec 2015 14:41:00 +0800</pubDate>
      
      <guid>http://icyleaf.com/2015/12/hexo-theme-next</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/2e2c5c6d351ebe899fcebed0f56a5b72b2660b06/687474703a2f2f696973736e616e2e636f6d2f6e657875732f6e6578742f6e6578742d736368656d65732e6a7067&#34; alt=&#34;Snapshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这是我见过配备最完善的 hexo 主题，支持丰富的配置，和 hexo 一样完善的文档。兼容国内外的扩展服务，最重要的主题作者还是国人。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文档：&lt;a href=&#34;http://theme-next.iissnan.com/&#34;&gt;http://theme-next.iissnan.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;源码：&lt;a href=&#34;https://github.com/iissnan/hexo-theme-next&#34;&gt;https://github.com/iissnan/hexo-theme-next&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>极速化 CocoaPods</title>
      <link>http://icyleaf.com/2015/01/speed-up-cocoapods</link>
      <pubDate>Tue, 20 Jan 2015 12:34:56 +0800</pubDate>
      
      <guid>http://icyleaf.com/2015/01/speed-up-cocoapods</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://cocoapods.org/&#34;&gt;Cocopods&lt;/a&gt; 本身是一个优秀的 iOS 开发的包管理工具，涵盖了 7k+ 的开源组件，包管理库是托管在 Github。
众所周知的原因它的速度日渐缓慢，有时会频繁报如下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pod install

Cloning into &#39;/path/to/ios/project/Pods/xxx&#39;

error: RPC failed; result=52, HTTP code = 0

fatal: The remote end hung up unexpectedly
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本文主要为解决该问题而诞生的，以下的加速方案不局限于目前已流传的优化方案，而是在此基础上&lt;strong&gt;彻底的加速&lt;/strong&gt;！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用淘宝 Ruby Gems 源（Cocoapods 使用 ruby 开发）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pod install&lt;/code&gt; 时不设置包的更新：&lt;a href=&#34;http://phatblat.com/blog/2014/07/30/pod-install/&#34;&gt;参考文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用国内 git 服务器镜像 Cocoapods Spec: &lt;a href=&#34;http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/&#34;&gt;参考文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你对 Cocoapods 有更深层次的理解，请参见：&lt;a href=&#34;http://www.objc.io/issue-6/cocoapods-under-the-hood.html&#34;&gt;objc.io: Cocoapods under the hood&lt;/a&gt; &lt;a href=&#34;http://objccn.io/issue-6-4/&#34;&gt;中文版本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今天早晨看到微博众多 iOS 开发者赞同转发《&lt;a href=&#34;http://weibo.com/p/1001603800875490492754&#34;&gt;CocoaPods最佳实践探讨&lt;/a&gt;》一文，
针对 &lt;code&gt;Pods&lt;/code&gt; 建议纳入版本控制也是无奈之举。之前公司项目中也是这样施行很长一段时间，不排除更新可能会造成很多无用信息&amp;rdquo;刷屏&amp;rdquo;，
偶尔还会因为版本冲突造成一些混乱状况需要处理。个人还是更倾向于精简原则，遵循&lt;a href=&#34;http://guides.cocoapods.org/using/using-cocoapods.html#should-i-ignore-the-pods-directory-in-source-control&#34;&gt;官方的建议&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;大家都是技术人员，其实这些小问题难道因为 github 倒下就没有解决方案了吗？！看我如何撕破这层纸老虎：&lt;/p&gt;

&lt;h3 id=&#34;技术概述&#34;&gt;技术概述&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Cocopods v0.34.0+&lt;/li&gt;
&lt;li&gt;Gitlab: 自建私有 git 服务器&lt;/li&gt;
&lt;li&gt;gitlab-mirrors: 专用于 github 镜像至 gitlab 并保持定期更新&lt;/li&gt;
&lt;li&gt;rake: ruby 的代码构建工具（不懂 ruby 的可以把它理解为命令聚合工具）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;技术剖析&#34;&gt;技术剖析&lt;/h3&gt;

&lt;p&gt;Cocoapods 自身支持&lt;a href=&#34;http://guides.cocoapods.org/making/private-cocoapods.html&#34;&gt;私有仓库&lt;/a&gt;，
恰好的是就在前不久发布的 &lt;a href=&#34;https://github.com/CocoaPods/CocoaPods/blob/master/CHANGELOG.md#0340&#34;&gt;0.34.0&lt;/a&gt; 版本支持 &lt;code&gt;Podfile&lt;/code&gt;
添加多个的包源仓库，举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;source &#39;https://github.com/artsy/Specs.git&#39;
source &#39;https://github.com/CocoaPods/Specs.git&#39;

pod &#39;AFNetworking&#39;
pod &#39;Mantle&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个特性其实是为了扩充官方 Spec 的同时可以更好的让开发者管理私有的公共组件，那我同样是从这里下手：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;前提是自己以及搭建好 gitlab 服务器：&lt;a href=&#34;https://about.gitlab.com/downloads/&#34;&gt;官方教程 （Ubuntu）&lt;/a&gt; | &lt;a href=&#34;http://icyleaf.com/2013/09/how-to-install-gitlab-on-centos/&#34;&gt;本人教程 （CentOS）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;自力更生&#34;&gt;自力更生&lt;/h4&gt;

&lt;p&gt;首先我们需要创建一个自己的 Spec 仓库，目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;.
├── CocoaPods-version.yml
├── Specs/
├── README.md
├── Rakefile
└── Gemfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置不做详细描述，这里比官方多了两个文件 &lt;code&gt;Rakefile&lt;/code&gt; 和 &lt;code&gt;Gemfile&lt;/code&gt; 都是 rake 所需的文件，这个后面会讲到。
再者就是配置 &lt;a href=&#34;https://github.com/samrocketman/gitlab-mirrors#three-easy-steps&#34;&gt;gitlab-mirrors&lt;/a&gt;，教程很详细不再重复。&lt;/p&gt;

&lt;h4 id=&#34;偷梁换柱&#34;&gt;偷梁换柱&lt;/h4&gt;

&lt;p&gt;利用私有 Spec 仓库特性，可以把官方 &lt;code&gt;Spec&lt;/code&gt; 目录下面的包按需或全部镜像过来，再次基础上&lt;strong&gt;把里面涉及 github 的地址替换成 gitlab 的地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你没有看错，这是核心步骤，如果这步没有做那么和国内镜像的地址没有任何差别。核心代码如下：&lt;/p&gt;

&lt;h5 id=&#34;rakefile&#34;&gt;Rakefile&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;uri&#39;
require &#39;fileutils&#39;
require &#39;multi_json&#39;
require &#39;net/ssh&#39;

desc &#39;镜像一个 github 包至 gitlab 仓库&#39;
task :clone, [:name] do |t, p|
  name = p[:name]
  current_path = Dir.pwd

  specs = Dir[File.join(File.expand_path(&#39;~&#39;), &#39;.cocoapods/repos/master/Specs/*&#39;)]

  repo = specs.select { |s| File.basename(s) == name }.first

  if repo
    puts &amp;quot; * found repo, copy it here&amp;quot;
    repo_store_path = File.join(current_path, &#39;Specs&#39;)
    FileUtils.cp_r repo, repo_store_path

    puts &amp;quot; * updating repo url&amp;quot;
    Dir[&amp;quot;#{repo_store_path}/#{name}/*&amp;quot;].each do |f|
      pod_file = File.join(f, &amp;quot;#{name}.podspec.json&amp;quot;)
      json = File.read(pod_file)
      data = MultiJson.load json

      if data[&#39;source&#39;][&#39;git&#39;]
        puts &amp;quot; -&amp;gt; #{data[&#39;version&#39;]}: git&amp;quot;
        orginal_repo_url = data[&#39;source&#39;][&#39;git&#39;]
        coverted_repo_name =  URI.parse(orginal_repo_url).path[1..-1].gsub(&#39;/&#39;, &#39;-&#39;).downcase
        data[&#39;source&#39;][&#39;git&#39;] = &amp;quot;http://gitlab.dev/mirrors/#{coverted_repo_name}&amp;quot;

        File.write(pod_file, JSON.pretty_generate(data))
      else data[&#39;source&#39;][&#39;http&#39;]
        puts &amp;quot; -&amp;gt; #{data[&#39;version&#39;]}: http url, do you want speed up?&amp;quot;
      else data[&#39;source&#39;][&#39;svn&#39;]
        puts &amp;quot; -&amp;gt; #{data[&#39;version&#39;]}: svn repo, do you want speed up?&amp;quot;
      end
    end
  else
    puts &amp;quot;Not find spec named: #{name}&amp;quot;
  end
end

desc &#39;gitlab 服务器镜像 Cocoapod Spec&#39;
task :mirror, [:repo] do |t, p|
  host        = &#39;172..0.1&#39;
  user        = &#39;icyleaf&#39;
  options     = {:keys =&amp;gt; &#39;~/.ssh/keys/id_rsa.pub&#39;}

  puts &amp;quot;Connect gitlab server and mirror&amp;quot;
  Net::SSH.start(host, user, options) do |ssh|
    gitmirror_path = &#39;/home/gitmirror/gitlab-mirrors&#39;
    cmd = &amp;quot;sudo -u gitmirror -H rake \&amp;quot;add[#{p[:repo]}]\&amp;quot;&amp;quot;
    stdout = ssh.exec!(&amp;quot;echo &#39;cd #{gitmirror_path} &amp;amp;&amp;amp; #{cmd}&#39;&amp;quot;)
    puts stdout
    ssh.loop
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;gemfile&#34;&gt;Gemfile&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;source &amp;quot;https://ruby.taobao.org&amp;quot;

gem &#39;rest_client&#39;
gem &#39;multi_json&#39;
gem &#39;rake&#39;
gem &#39;net-ssh&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rake&lt;/code&gt; 里面有两个 task：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mirror: 镜像 iOS 开源组件&lt;/li&gt;
&lt;li&gt;clone: 负责把官方 spec 指定包（开源组件的版本控制）替换 gitlab 地址并加入到私有包仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;通过工具总有办法可以改进和提升开发者的效率和解决各种的问题，希望本文可以给大家带来更多的灵感！&lt;/p&gt;

&lt;h3 id=&#34;答疑解惑&#34;&gt;答疑解惑&lt;/h3&gt;

&lt;h5 id=&#34;f-这套理论靠谱吗&#34;&gt;F: 这套理论靠谱吗？&lt;/h5&gt;

&lt;p&gt;A: 目前我们团队已经采用并运行了很长一段时间，没有任何风险。最大的优势在于兼容官方的仓库，
就算无法链接自己的私有服务器，使用官方和国内镜像的都可以瞬间切换。&lt;/p&gt;

&lt;h5 id=&#34;f-如果没有服务器可以实现吗&#34;&gt;F: 如果没有服务器可以实现吗？&lt;/h5&gt;

&lt;p&gt;A: 醒醒吧孩子，就连单纯的镜像官方 Cocoapods Spec 还需要一个服务器执行定期同步脚本呢。&lt;/p&gt;

&lt;h5 id=&#34;f-国内-git-托管服务器能够支持吗&#34;&gt;F: 国内 git 托管服务器能够支持吗？&lt;/h5&gt;

&lt;p&gt;A: 据我所知国内大部分 git 托管服务器的解决方案都是基于 gitlab 二次开发的，理论上可行，
上面提到的 gitlab-mirror 本身依赖于 gitlab 的 api 在镜像的同时自动新建仓库。如果有成功的欢迎反馈。&lt;/p&gt;

&lt;h5 id=&#34;f-我从你代码发现服务器同样调用了一个-rake-脚本-你没有开源&#34;&gt;F: 我从你代码发现服务器同样调用了一个 rake 脚本，你没有开源！&lt;/h5&gt;

&lt;p&gt;A: 眼睛真够敏锐的，个人对 gitlab-mirror 再做镜像时做了一个约束，新建一个 &lt;code&gt;Rakefile&lt;/code&gt; 文件放到你的 gitlab-mirror 项目根目录即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;uri&#39;

desc &amp;quot;Adding repo to gitmirror&amp;quot;
task :add, [:repo] do |t, p|
  repo = p[:repo]

  begin
    name = URI.parse(repo).path[1..-1].gsub(&#39;/&#39;, &#39;-&#39;).gsub(&#39;.git&#39;, &#39;&#39;)
    if name
      `./add_mirror.sh -f --git --project-name #{name} --mirror #{repo}`
    end
  rescue Error =&amp;gt; e
    puts &#39;not url&#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;f-我还有问题&#34;&gt;F: 我还有问题！&lt;/h5&gt;

&lt;p&gt;A: 麻烦请留言，谢谢！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>