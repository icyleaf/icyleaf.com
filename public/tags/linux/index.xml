<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on icyleaf</title>
    <link>localhost/tags/linux/</link>
    <description>Recent content in Linux on icyleaf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2007</copyright>
    <lastBuildDate>Wed, 22 Jan 2014 12:34:56 +0800</lastBuildDate>
    <atom:link href="localhost/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux 101 系列：ssh OpenSSH 客户端工具</title>
      <link>/localhost/2014/01/linux-101-ssh</link>
      <pubDate>Wed, 22 Jan 2014 12:34:56 +0800</pubDate>
      
      <guid>/localhost/2014/01/linux-101-ssh</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;使用 *nix 服务器肯定会用到 ssh，它是一个链接到远程服务器终端的工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;基本常识&#34;&gt;基本常识&lt;/h2&gt;

&lt;h3 id=&#34;基本组成部分&#34;&gt;基本组成部分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ man ssh
ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]
     [-D [bind_address:]port] [-e escape_char] [-F configfile] [-I pkcs11]
     [-i identity_file] [-L [bind_address:]port:host:hostport]
     [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]
     [-R [bind_address:]port:host:hostport] [-S ctl_path] [-W host:port]
     [-w local_tun[:remote_tun]] [user@]hostname [command]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有没有被帮助手册的参数吓到，那我们精简一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ssh [user@]hostname [-p port]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;登录到远程服务器和登录本地电脑系统没什么大的区别，都需要用户名，密码，除此之外我们还需要知道远程服务器的地址（IP 地址或域名均可）及允许的端口（默认 22 端口）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh root@10.10.10.10 -p 22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些时候大家发现一些教程没有提到用户，实际上 ssh 很聪明，默认会使用当前系统的用户名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(icyleaf) $ ssh 10.10.10.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就等同于&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh icyleaf@10.10.10.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些服务器可能为了安全期间修改了默认的端口，比如 2020：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh icyleaf@10.10.10.10 -p 2020
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;高级参数&#34;&gt;高级参数&lt;/h3&gt;

&lt;h4 id=&#34;socket-代理&#34;&gt;Socket 代理&lt;/h4&gt;

&lt;p&gt;呐，你可能因为 GFW 的威力，尝试使用 ssh 的 socket 代理，实际上就是用到的 &lt;code&gt;-D&lt;/code&gt; 参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-D [bind_address:]port
   Specifies a local ``dynamic application-level port forwarding.
   This works by allocating a socket to listen to port on the local
   side, optionally bound to the specified bind_address.  Whenever a
   connection is made to this port, the connection is forwarded over
   the secure channel, and the application protocol is then used to
   determine where to connect to from the remote machine.  Currently
   the SOCKS4 and SOCKS5 protocols are supported, and ssh will act
   as a SOCKS server.  Only root can forward privileged ports.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来简单画下它的工作流程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|----client----|                    |-----server----|
|              |                    |               |
|   local port&amp;lt;|  &amp;lt;incoming         |               |
|    ssh port&amp;lt;&amp;gt;|  &amp;lt;--------------&amp;gt;  |&amp;lt;&amp;gt; ssh port    |
                                    |    forwarding&amp;gt;|  &amp;gt;outgoing connection

                                     &amp;lt;&amp;lt;&amp;lt;------------local network-----------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它首先需要登录到远程服务器，并把本地的请求全部转发到服务器指定的端口上，然后通过由服务器再去请求。例如我们设置 8624 端口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -D8624 icyleaf@10.10.10.10 -p 22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样保持这个连接，我们在设置浏览器或系统的 socket4/5 代理就能达到翻墙的目的。当前这个最大的前提是你的服务器在不手 GFW 的控制下（任意海外未被 GFW 服务器）&lt;/p&gt;

&lt;h4 id=&#34;跳板代理&#34;&gt;跳板代理&lt;/h4&gt;

&lt;p&gt;或许曾经你在看某本黑客杂志或电影出现过这样的片段，黑客使用肉鸡跳板不断的增加难度避开警察的追踪，实际上我们通过 ssh 也能非常简单又很酷的实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-L [bind_address:]port:host:hostport
   Specifies that the given port on the local (client) host is to be
   forwarded to the given host and port on the remote side.  This
   works by allocating a socket to listen to port on the local side,
   optionally bound to the specified bind_address.  Whenever a con-
   nection is made to this port, the connection is forwarded over
   the secure channel, and a connection is made to host port
   hostport from the remote machine.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样给出工作流程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|----client----|                    |-----server----|                 |-----host-----|
|              |                    |               |                 |              |
|   local port&amp;lt;|  &amp;lt;incoming         |               |                 |              |
|    ssh port&amp;lt;&amp;gt;|  &amp;lt;--------------&amp;gt;  |&amp;lt;&amp;gt; ssh port    |                 |              |
                                    |    forwarding&amp;gt;|  -------------&amp;gt; |&amp;gt;host port    |

                                     &amp;lt;&amp;lt;&amp;lt;------------local network-------------------&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上我只需要操作 &lt;code&gt;-L [bind_address:]port:host:hostport&lt;/code&gt; 即可。这里假设我们想登录的目标服务器 target(10.10.10.10)，而我们希望在肉鸡 chicken(20.20.20.20) 上做成跳板：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -L2020:20.20.20.20:22 10.10.10.10
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;简化配置&#34;&gt;简化配置&lt;/h3&gt;

&lt;p&gt;反复的输入这些繁琐的参数，甚是苦恼，能不能通过一种起个别名就能把上面的参数全部自动设置好呢？！没问题！&lt;/p&gt;

&lt;p&gt;创建 &lt;code&gt;~/.ssh/config&lt;/code&gt; 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host linode
HostName 10.10.10.10
Port 22
User icyleaf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就是基本组成部分。如果你想配置更多，下面是完整的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AddressFamily
BatchMode
BindAddress
ChallengeResponseAuthentication
CheckHostIP
Cipher
Ciphers
ClearAllForwardings
Compression
CompressionLevel
ConnectionAttempts
ConnectTimeout
ControlMaster
ControlPath
ControlPersist
DynamicForward
EscapeChar
ExitOnForwardFailure
ForwardAgent
ForwardX11
ForwardX11Timeout
ForwardX11Trusted
GatewayPorts
GlobalKnownHostsFile
GSSAPIAuthentication
GSSAPIDelegateCredentials
HashKnownHosts
Host
HostbasedAuthentication
HostKeyAlgorithms
HostKeyAlias
HostName
IdentityFile
IdentitiesOnly
IPQoS
KbdInteractiveAuthentication
KbdInteractiveDevices
KexAlgorithms
LocalCommand
LocalForward
LogLevel
MACs
NoHostAuthenticationForLocalhost
NumberOfPasswordPrompts
PasswordAuthentication
PermitLocalCommand
PKCS11Provider
Port
PreferredAuthentications
Protocol
ProxyCommand
PubkeyAuthentication
RekeyLimit
RemoteForward
RequestTTY
RhostsRSAAuthentication
RSAAuthentication
SendEnv
ServerAliveInterval
ServerAliveCountMax
StrictHostKeyChecking
TCPKeepAlive
Tunnel
TunnelDevice
UsePrivilegedPort
User
UserKnownHostsFile
VerifyHostKeyDNS
VisualHostKey
XAuthLocation
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;配置文件&#34;&gt;配置文件&lt;/h3&gt;

&lt;p&gt;刚才讲到的 &lt;code&gt;~/.ssh/config&lt;/code&gt; 是配置 ssh 服务器的文件，其实除了这些还有好多，比如大家可能会经常见到的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/.ssh/config
  This is the per-user configuration file.  The file format and
  configuration options are described in ssh_config(5).  Because of
  the potential for abuse, this file must have strict permissions:
  read/write for the user, and not accessible by others.

~/.ssh/authorized_keys
  Lists the public keys (DSA/ECDSA/RSA) that can be used for log-
  ging in as this user.  The format of this file is described in
  the sshd(8) manual page.  This file is not highly sensitive, but
  the recommended permissions are read/write for the user, and not
  accessible by others.

~/.ssh/identity
~/.ssh/id_dsa
~/.ssh/id_ecdsa
~/.ssh/id_rsa
  Contains the private key for authentication.  These files contain
  sensitive data and should be readable by the user but not acces-
  sible by others (read/write/execute).  ssh will simply ignore a
  private key file if it is accessible by others.  It is possible
  to specify a passphrase when generating the key which will be
  used to encrypt the sensitive part of this file using 3DES.

~/.ssh/identity.pub
~/.ssh/id_dsa.pub
~/.ssh/id_ecdsa.pub
~/.ssh/id_rsa.pub
  Contains the public key for authentication.  These files are not
  sensitive and can (but need not) be readable by anyone.

~/.ssh/known_hosts
  Contains a list of host keys for all hosts the user has logged
  into that are not already in the systemwide list of known host
  keys.  See sshd(8) for further details of the format of this
  file.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/.rhosts
  This file is used for host-based authentication (see above).  On
  some machines this file may need to be world-readable if the
  user&#39;s home directory is on an NFS partition, because sshd(8)
  reads it as root.  Additionally, this file must be owned by the
  user, and must not have write permissions for anyone else.  The
  recommended permission for most machines is read/write for the
  user, and not accessible by others.

~/.shosts
  This file is used in exactly the same way as .rhosts, but allows
  host-based authentication without permitting login with
  rlogin/rsh.

~/.ssh/
  This directory is the default location for all user-specific con-
  figuration and authentication information.  There is no general
  requirement to keep the entire contents of this directory secret,
  but the recommended permissions are read/write/execute for the
  user, and not accessible by others.

~/.ssh/environment
  Contains additional definitions for environment variables; see
  ENVIRONMENT, above.

~/.ssh/rc
  Commands in this file are executed by ssh when the user logs in,
  just before the user&#39;s shell (or command) is started.  See the
  sshd(8) manual page for more information.

/etc/hosts.equiv
  This file is for host-based authentication (see above).  It
  should only be writable by root.

/etc/shosts.equiv
  This file is used in exactly the same way as hosts.equiv, but
  allows host-based authentication without permitting login with
  rlogin/rsh.

/etc/ssh/ssh_config
  Systemwide configuration file.  The file format and configuration
  options are described in ssh_config(5).

/etc/ssh/ssh_host_key
/etc/ssh/ssh_host_dsa_key
/etc/ssh/ssh_host_ecdsa_key
/etc/ssh/ssh_host_rsa_key
  These files contain the private parts of the host keys and are
  used for host-based authentication.  If protocol version 1 is
  used, ssh must be setuid root, since the host key is readable
  only by root.  For protocol version 2, ssh uses ssh-keysign(8) to
  access the host keys, eliminating the requirement that ssh be
  setuid root when host-based authentication is used.  By default
  ssh is not setuid root.

/etc/ssh/ssh_known_hosts
  Systemwide list of known host keys.  This file should be prepared
  by the system administrator to contain the public host keys of
  all machines in the organization.  It should be world-readable.
  See sshd(8) for further details of the format of this file.

/etc/ssh/sshrc
  Commands in this file are executed by ssh when the user logs in,
  just before the user&#39;s shell (or command) is started.  See the
  sshd(8) manual page for more information.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;资料参考：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;[Linux] man ssh&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.openfsg.com/index.php/Advanced_SSH_usage&#34;&gt;Advanced SSH usage&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Git 和 Pager 的那点事</title>
      <link>/localhost/2013/10/about-pager-on-git</link>
      <pubDate>Wed, 16 Oct 2013 12:34:56 +0800</pubDate>
      
      <guid>/localhost/2013/10/about-pager-on-git</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Git 几乎所有命令都提供分页器，即当命令输出超过一页时，自动在每页输出后暂停，可以按空格继续显示，按 q 退出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;默认 git 的 &lt;code&gt;pager = less -FRSX&lt;/code&gt;，这个可以通过两种方式更改：&lt;/p&gt;

&lt;p&gt;命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global core.pager &amp;quot;less -FRSX&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim ~/.gitconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;了不起了通过设置自动匹配的色彩来增强可读性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global color.ui on 	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随着 &lt;a href=&#34;http://jonas.nitro.dk/tig&#34;&gt;tig&lt;/a&gt; 的出现，给 git 的增加了一个强大武装武器。（不明观众看这里先对它有个感官概念：&lt;a href=&#34;http://gitready.com/advanced/2009/07/31/tig-the-ncurses-front-end-to-git.html&#34;&gt;tig, the ncurses front-end to Git&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;可能大家不知道 tig 本身就可以也是一个 pager，因此我们可以在 git config 默认替换之：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global core.pager tig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自从这样配置之后，让我幸福了好几年。直到&amp;hellip;今天发现一个怪异的问题，使用任何需要显示 tig pager 的地方设置的配色是以代码形式显示，而不是解析成了终端显示的颜色。最近忍不住升级到了 10.9 并更新了一些命令，因此也没搞清楚到底是哪里出了问题。只能先把 git 自带的 color 渲染给关闭才解决了这个问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global color.ui off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的个人 &lt;code&gt;.gitconfig&lt;/code&gt; 等配置文件：&lt;a href=&#34;https://gist.github.com/icyleaf/868866&#34;&gt;https://gist.github.com/icyleaf/868866&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何在 CentOS 上安装 Gitlab</title>
      <link>/localhost/2013/09/how-to-install-gitlab-on-centos</link>
      <pubDate>Tue, 17 Sep 2013 12:34:56 +0800</pubDate>
      
      <guid>/localhost/2013/09/how-to-install-gitlab-on-centos</guid>
      <description>

&lt;p&gt;2013 年 08 月的 OpenParty &amp;ldquo;&lt;a href=&#34;http://www.beijing-open-party.org/event/25&#34;&gt;花事如期&lt;/a&gt;&amp;rdquo; 活动上，&lt;a href=&#34;https://github.com/vecio&#34;&gt;晓东&lt;/a&gt;在他的机器上演示了自建 Gitlab 的项目，看到 Gitlab 目前已经比较成熟，而不像早期寒碜的界面，这个时候看安装一下也是不错的事情，不过他们的项目文档只提供了 Ubuntu 系统的&lt;a href=&#34;https://github.com/gitlabhq/gitlabhq#installation&#34;&gt;安装文档&lt;/a&gt;，对于 CentOS 没有提到，非官方的文档有比较老久，凭着之前熟悉 Ubuntu 和学习 CentOS，那就开始安装吧：&lt;/p&gt;

&lt;p&gt;以下教程在 &lt;code&gt;CentOS 6 x86_64&lt;/code&gt; 版本下操作。&lt;/p&gt;

&lt;h2 id=&#34;首先安装-epel-和编译依赖库&#34;&gt;首先安装 EPEL 和编译依赖库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ rpm -ivh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你是非 64 位，去上面的网址找到适合你发行版的最新版本的 epel rpm&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ yum -y update
$ yum -y install gcc gcc-c++ make autoconf libyaml-devel gdbm-devel ncurses-devel openssl-devel zlib-devel readline-devel curl-devel expat-devel gettext-devel  tk-devel libxml2-devel libffi-devel libxslt-devel libicu-devel sendmail patch libyaml* pcre-devel sqlite-devel vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装-python-2-7&#34;&gt;安装 Python 2.7+&lt;/h2&gt;

&lt;p&gt;Gitlab 要求 Python 2.5.5+ 以及 Ruby 1.9+&lt;/p&gt;

&lt;p&gt;系统 Python 默认是 2.6.x，如果你想把 Python 升级到目前比较流行的 2.7.x 就参照下面步骤，否则直接跳过。（Gitlab 目前不支持 Python 3.0）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir /tmp/gitlab &amp;amp;&amp;amp; cd /tmp/gitlab
$ curl --progress http://python.org/ftp/python/2.7.5/Python-2.7.5.tgz | tar xvf
$ cd Python-2.7.5
$ ./configure --prefix=/usr/local
$ make &amp;amp;&amp;amp; make altinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好之后，需要做两件事情，替换默认 python 的版本至最新版本，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ln -s /usr/local/bin/python2.7 /usr/local/bin/python
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;因为系统默认 &lt;code&gt;PATH&lt;/code&gt; 的寻址路径是 &lt;code&gt;/usr/local/bin&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后看下 Python 版本是否是刚刚安装的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python --version
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;由于 &lt;code&gt;yum&lt;/code&gt; 是 python 的一个 module，所以这块修改可能会引起无法调用 yum 脚本，所以需要修改这个文件 &lt;code&gt;/usr/bin/yum&lt;/code&gt; 的第一行为 &lt;code&gt;!#/usr/bin/python2.6&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;安装-ruby-2-0&#34;&gt;安装 Ruby 2.0&lt;/h2&gt;

&lt;p&gt;Ruby 1.9 和 2.0 的特性差别不大，索性升级至最新 2.0 版本即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /tmp/gitlab
$ curl --progress http://cache.ruby-lang.org/pub/ruby/2.0/ruby-2.0.0-p247.tar.gz | tar xz
$ cd ruby-2.0.0-p247
$ ./configure
$ make
$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ruby 2.0 已经内置 gem (v2.0.3)，只需要安装 bundler&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install bundler
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;若在执行 &lt;code&gt;sudo ruby&lt;/code&gt; 或 &lt;code&gt;sudo gem&lt;/code&gt; 找不到命令，因为编译的路径配置到了 &lt;code&gt;/usr/local/bin&lt;/code&gt;，我们只需要做下软链接到 root 用户可以找到的 &lt;code&gt;$PATH&lt;/code&gt; 路径：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ ln -s /usr/local/bin/ruby /usr/bin/ruby
$ ln -s /usr/local/bin/gem /usr/bin/gem
$ ln -s /usr/local/bin/bundle /usr/bin/bundle
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装-git-和-gitolite&#34;&gt;安装 Git 和 Gitolite&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ yum -y install git-all gitolite
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装-nginx&#34;&gt;安装 Nginx&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ yum -y install nginx
$ service nginx start
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;nginx 需要从 EPEL 中安装，默认系统没有 nginx 包。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;安装-mysql-和-redis&#34;&gt;安装 Mysql 和 Redis&lt;/h2&gt;

&lt;p&gt;Gitlab 要求强制安装 redis 处理一些数据，另外支持 MySQL 和 PostgreSQL，这里主要以 MySQL 为例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum -y install mysql mysql-devel mysql-server redis
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置 Mysql 和 gitlab 需要的用户和数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ service mysqld start
$ mysql -u root
$ mysql&amp;gt; CREATE USER &#39;gitlab&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;gitlab&#39;;
$ mysql&amp;gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`;
$ mysql&amp;gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO &#39;gitlab&#39;@&#39;localhost&#39;;
$ mysql&amp;gt; \q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redis 使用默认配置即可，直接启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ service redis start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;添加-gitlab-用户&#34;&gt;添加 Gitlab 用户&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ useradd -c &#39;GitLab&#39; git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CentOS 的命令没有办法直接禁止用户的访问的参数，需要用下面命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ passwd -l git 	
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装-gitlab-shell&#34;&gt;安装 Gitlab-shell&lt;/h2&gt;

&lt;p&gt;使用 root 账户切换到 git 账户下操作，可以比官方教程省去一些麻烦的输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ su git &amp;amp;&amp;amp; cd /home/git
$ git clone https://github.com/gitlabhq/gitlab-shell.git
$ cd gitlab-shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;git tag&lt;/code&gt; 查看最新版本并切换之&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout v1.7.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑配置文件修改你要设定的域名（domain），比如 &lt;code&gt;http://gitlab.dev/&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim config.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成之后执行安装脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./bin/install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装-gitlab&#34;&gt;安装 Gitlab&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd /home/git
$ git clone https://github.com/gitlabhq/gitlabhq.git gitlab
$ cd /home/git/gitlab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;git tag&lt;/code&gt; 查看最新版本并切换之&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout 6.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里需要配置的东西多一些，这里参考&lt;a href=&#34;https://github.com/gitlabhq/gitlabhq/blob/master/doc/install/installation.md#configure-it&#34;&gt;官方的文档&lt;/a&gt;，也可以安装我下面的步骤来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /home/git/gitlab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制配置文件，修改 host 相关的配置项，主要是 domain 要和上面的 &lt;code&gt;http://gitlab.dev&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp config.yml{.example,}
$ vim config/gitlab.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确认 gitlab 以下目录的权限是否正确&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir tmp/pids/
$ mkdir tmp/sockets/
$ chown -R git log/
$ chown -R git tmp/
$ chmod -R u+rwX log/
$ chmod -R u+rwX tmp/
$ chmod -R u+rwX tmp/pids/
$ chmod -R u+rwX tmp/sockets/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 satellites 目录，这个目录是保存各个用户的仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir /home/git/gitlab-satellites
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 uploads 目录（为什么 gitlab 不在项目中创建呢= =！）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir public/uploads
$ chmod -R u+rwX  public/uploads
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制 unicorn 配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp config/unicorn.rb{.example,}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置 ruby web 容器的参数，比如 2GB RAM 服务器可以设置 3 个 worker。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果系统其他服务占用了 unicorn 的端口，记得改名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;$ vim config/unicorn.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置一些 git 全局参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &amp;quot;GitLab&amp;quot;
$ git config --global user.email &amp;quot;gitlab@localhost&amp;quot;
$ git config --global core.autocrlf input
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置 gitlab 数据库设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp config/database.yml{.mysql,}
$ vim config/database.yml
$ chmod o-rwx config/database.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装必需的 Ruby Gems&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /home/git/gitlab
$ [sudo] gem install charlock_holmes --version &#39;0.6.9.4&#39;
$ bundle install --deployment --without development test postgres aws
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化数据库数据（执行输入 &lt;code&gt;Yes&lt;/code&gt; 继续创建）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bundle exec rake gitlab:setup RAILS_ENV=production
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置 init 脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo cp lib/support/init.d/gitlab /etc/init.d/gitlab
$ sudo chmod +x /etc/init.d/gitlab
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;检查-gitlab-状态&#34;&gt;检查 Gitlab 状态&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ bundle exec rake gitlab:env:info RAILS_ENV=production
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 gitlab 服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo service gitlab start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再起检查，保证所有项目都是绿色&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bundle exec rake gitlab:check RAILS_ENV=production
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置-nginx&#34;&gt;配置 nginx&lt;/h2&gt;

&lt;p&gt;根据 nginx 的安装路径适当修改下面的路径即可，我们先把 gitlab 提供的配置文件拷贝过去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo mkdir -p /etc/nginx/conf/sites/
$ sudo cp lib/support/nginx/gitlab /etc/nginx/conf/sites/gitlab.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;根据 nginx 版本和不同发行版的不同，配置结构可能不同根据你的实际情况加载 &lt;code&gt;gitlab.conf&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改 &lt;code&gt;gitlab.conf&lt;/code&gt; 的 &lt;code&gt;YOUR_SERVER_FQDN&lt;/code&gt; 为上面设置的 domain。
最后修改 &lt;code&gt;nginx.conf&lt;/code&gt; 或者 &lt;code&gt;default.conf&lt;/code&gt; 加载 &lt;code&gt;/etc/nginx/conf/site&lt;/code&gt; 下所有 conf 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {

	include /etc/nginx/conf/site/*.conf;

	server {
		…
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存后，重启各个服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo service nginx reload
$ sudo service gitlab restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;开始-gitlab-之旅&#34;&gt;开始 Gitlab 之旅&lt;/h2&gt;

&lt;p&gt;配置好 hosts 即可访问 &lt;code&gt;gitlab.dev&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;127.0.0.1 gitlab.dev&amp;quot; &amp;gt;&amp;gt; /etc/hosts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认的用户名密码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;admin@local.host
5iveL!fe
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;各种坑&#34;&gt;各种坑&lt;/h2&gt;

&lt;h3 id=&#34;1-错误日志报权限错误&#34;&gt;1. 错误日志报权限错误&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;2013/11/07 00:42:21 [crit] 15875#0: *2 stat() &amp;quot;/home/git/gitlab/public/favicon.ico.html&amp;quot; failed (13: Permission denied), client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:21 [crit] 15875#0: *2 connect() to unix:/home/git/gitlab/tmp/sockets/gitlab.socket failed (13: Permission denied) while connecting to upstream, client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot;, upstream: &amp;quot;http://unix:/home/git/gitlab/tmp/sockets/gitlab.socket:/favicon.ico&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:31 [crit] 15875#0: *2 stat() &amp;quot;/home/git/gitlab/public/&amp;quot; failed (13: Permission denied), client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET / HTTP/1.1&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:31 [crit] 15875#0: *2 stat() &amp;quot;/home/git/gitlab/public//index.html&amp;quot; failed (13: Permission denied), client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET / HTTP/1.1&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:31 [crit] 15875#0: *2 stat() &amp;quot;/home/git/gitlab/public/.html&amp;quot; failed (13: Permission denied), client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET / HTTP/1.1&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:31 [crit] 15875#0: *2 connect() to unix:/home/git/gitlab/tmp/sockets/gitlab.socket failed (13: Permission denied) while connecting to upstream, client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET / HTTP/1.1&amp;quot;, upstream: &amp;quot;http://unix:/home/git/gitlab/tmp/sockets/gitlab.socket:/&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:31 [crit] 15875#0: *2 stat() &amp;quot;/home/git/gitlab/public/favicon.ico&amp;quot; failed (13: Permission denied), client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:31 [crit] 15875#0: *2 stat() &amp;quot;/home/git/gitlab/public/favicon.ico/index.html&amp;quot; failed (13: Permission denied), client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:31 [crit] 15875#0: *2 stat() &amp;quot;/home/git/gitlab/public/favicon.ico.html&amp;quot; failed (13: Permission denied), client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
2013/11/07 00:42:31 [crit] 15875#0: *2 connect() to unix:/home/git/gitlab/tmp/sockets/gitlab.socket failed (13: Permission denied) while connecting to upstream, client: 33.33.33.1, server: gitlab.web.lo, request: &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot;, upstream: &amp;quot;http://unix:/home/git/gitlab/tmp/sockets/gitlab.socket:/favicon.ico&amp;quot;, host: &amp;quot;gitlab.web.lo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ (sudo) chmod o+x /home/git
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-8080-端口被占用&#34;&gt;2. 8080 端口被占用&lt;/h3&gt;

&lt;p&gt;这样主要是因为 nginx 的配置是做 unicorn 的代理转发，实际上 gitlab 是由 unicorn 容器驱动，而在配置里默认绑定的是 &lt;code&gt;8080&lt;/code&gt; 端口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim /home/git/gitlab/config/unicorn.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到 &lt;code&gt;listen &amp;quot;127.0.0.1:8080&amp;quot;, :tcp_nopush =&amp;gt; true&lt;/code&gt; 修改成其他未占用的端口号即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>配置 CentOS 的网络联网设置</title>
      <link>/localhost/2013/09/network-configuration-in-centos</link>
      <pubDate>Thu, 05 Sep 2013 12:34:56 +0800</pubDate>
      
      <guid>/localhost/2013/09/network-configuration-in-centos</guid>
      <description>

&lt;p&gt;安装完毕 CentOS 6 Server 开始配置网络设置，网上有很多的教程，用的方法要么不全，要么操作方式比较早期，花点时间整理了下方法：&lt;/p&gt;

&lt;h2 id=&#34;dhcp-设定&#34;&gt;DHCP 设定&lt;/h2&gt;

&lt;p&gt;CentOS 默认使用了 &lt;code&gt;dhcp&lt;/code&gt; 但是可恨的是没有开启。首先我们先看看本机的网卡信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ip a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1: lo:  mtu 16436 qdisc noqueue state UNKNOWN
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
inet6 ::1/128 scope host
valid_lft forever preferred_lft forever
2: eth0:  mtu 1500 qdisc mq state UP qlen 1000
link/ether 00:22:19:09:4d:3c brd ff:ff:ff:ff:ff:ff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;lo&lt;/code&gt; 是回路路由，咱们不必管它，这里 &lt;code&gt;eth0&lt;/code&gt; 大家会很熟悉吧，这表示第一块网卡。好了，我们需要改改它的配置文件(CentOS 默认没有安装 &lt;code&gt;vim&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi /etc/sysconfig/network-scripts/ifcfg-eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你要改其他网卡，比如 &lt;code&gt;eth1&lt;/code&gt; 那需要修改 &lt;code&gt;/etc/.../ifcfg-eth1&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEVICE=eth0
HWADDR=&amp;quot;00:22:19:09:4D:3C&amp;quot;
NM_CONTROLLED=yes
ONBOOT=yes      # 默认是 no，我们要改成 yes
BOOTPROTO=dhcp  # 如果不是这个值也要修改
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后重启 network service 即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ service network restart
# 或者比较原始的方法
$ /etc/init.d/network restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你看到它在重启并配置 DHCP 服务，那就说明没有问题了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Bringing up loopback interface:                [  OK  ]
Bringing up interface eth0:
Determining IP information for eth0... done.   [  OK  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping google.com
$ ifconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;手动设定&#34;&gt;手动设定&lt;/h2&gt;

&lt;p&gt;大部分操作和上面的一直，唯一不同的就是修改 &lt;code&gt;/etc/sysconfig/network-scripts/ifcfg-*&lt;/code&gt; 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEVICE=eth0
HWADDR=&amp;quot;00:22:19:09:4D:3C&amp;quot;
NM_CONTROLLED=yes
ONBOOT=yes      		# 默认是 no，我们要改成 yes
BOOTPROTO=static  		# 改成静态模式
IPADDR=192.168.1.11 	# 设定 ip 地址
NETMASK=255.255.255.0 	# 设定子网掩码
GATEWAY=192.168.1.1 	# 设定网关 ip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 DNS 地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi /etc/resolve.conf

nameserver 8.8.8.8 # 主 DNS
nameserver 8.8.4.4 # 备选 DNS
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux 101 系列：chmod 文件权限工具</title>
      <link>/localhost/2013/08/linux-101-chmod</link>
      <pubDate>Wed, 28 Aug 2013 12:34:56 +0800</pubDate>
      
      <guid>/localhost/2013/08/linux-101-chmod</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;chmod 是用来管理文件访问权限的命令，大家是使用 *nix 系统的时候经常跟它打交道。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;基本常识&#34;&gt;基本常识&lt;/h2&gt;

&lt;h3 id=&#34;用户和用户组&#34;&gt;用户和用户组&lt;/h3&gt;

&lt;p&gt;参数|英文|说明
&amp;ndash;|&amp;ndash;|&amp;ndash;
u|Use|当前用户
g|Group|所属用户组
o|Others|其他人（其他用户及用户组，包含访客用户）&lt;/p&gt;

&lt;h3 id=&#34;数字与参数&#34;&gt;数字与参数&lt;/h3&gt;

&lt;p&gt;数字|符号|说明|对文件|对目录
&amp;ndash;|&amp;ndash;|&amp;ndash;|&amp;ndash;|&amp;ndash;
1|x|可执行权限|可被系统执行的权限| 无
2|w|写权限|可以编辑或修改文件内容，但不含删除该文件|增删改该目录及目录下全部文件
4|r|读权限|可读取文件的内容|可读取目录结构&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;备注：&lt;code&gt;ls -l&lt;/code&gt;对于文件权限是由 rwx 倒序组成。比如 &lt;code&gt;-rwxr--r--&lt;/code&gt;，说明当前用户拥有全部权限，所属用户组和其他人只有读权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;

&lt;h3 id=&#34;数字篇&#34;&gt;数字篇&lt;/h3&gt;

&lt;h4 id=&#34;1-当前用户拥有所有权限-其他只有读权限&#34;&gt;1. 当前用户拥有所有权限，其他只有读权限&lt;/h4&gt;

&lt;p&gt;u|g|o
-|-|-
6|4|4
rw|r|r&lt;/p&gt;

&lt;h4 id=&#34;2-所有用户及用户组添加全部权限-谨慎使用&#34;&gt;2. 所有用户及用户组添加全部权限 （&lt;strong&gt;谨慎使用&lt;/strong&gt;）&lt;/h4&gt;

&lt;p&gt;u|g|o
-|-|-
7|7|7
rwx|rwx|rwx&lt;/p&gt;

&lt;h3 id=&#34;符号篇&#34;&gt;符号篇&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;通用公式：[用户(组)] + [操作] + [符号]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;操作&lt;/code&gt;是由如下表构成：&lt;/p&gt;

&lt;p&gt;操作|说明
&amp;ndash;|&amp;ndash;
-|移除权限
+|增加权限
=|设定权限&lt;/p&gt;

&lt;h4 id=&#34;1-所有用户及用户组添加执行权限&#34;&gt;1. 所有用户及用户组添加执行权限&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ chmod +x [file]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;2-不允许其他人有写权限&#34;&gt;2. 不允许其他人有写权限&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ chmod o-w [file]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-增加用户组的读写权限&#34;&gt;3. 增加用户组的读写权限&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ chmod g+rw [file]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-除了当前用户都移除读写权限&#34;&gt;4. 除了当前用户都移除读写权限&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ chmod go-rw [file]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-设置当前用户所有权限-所属用户组和其他人保留读权限&#34;&gt;5. 设置当前用户所有权限，所属用户组和其他人保留读权限&lt;/h4&gt;

&lt;p&gt;```
$ chmod u=rwx,g=r,o=r [file]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSX</title>
      <link>/localhost/2010/12/switer-between-finder-and-terminal-in-osx</link>
      <pubDate>Wed, 08 Dec 2010 12:34:56 +0800</pubDate>
      
      <guid>/localhost/2010/12/switer-between-finder-and-terminal-in-osx</guid>
      <description>&lt;p&gt;&lt;strong&gt;在 Finder 打开 Terminal 并切换到当前目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安装一个开源的 Finder 辅助工具：&lt;a href=&#34;http://code.google.com/p/cdto/&#34;&gt;cdto&lt;/a&gt;。功能只有一个就是实现在 Finder
打开 Terminal 并切换到当前 Finder 目录。找到你系统的版本的 app （支持当前
OS X 10.4 以上版本，应该都是雪豹了 吧）拷贝到 Applications 下并把它拖到
Finder 的工具栏上即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从 Terminal 中用 Finder 打开当前路径的目录&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ open .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PS，如果是 Ubuntu 系统的话请安装 nautilus，然后在 Terminal 里面输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nautilus .
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 解决 public key is not available 问题</title>
      <link>/localhost/2010/11/apt-get-gpg-error-public-key-not-available</link>
      <pubDate>Wed, 03 Nov 2010 12:34:56 +0800</pubDate>
      
      <guid>/localhost/2010/11/apt-get-gpg-error-public-key-not-available</guid>
      <description>&lt;p&gt;自 Ubuntu 10.04 升级至 10.10 之后，系统就有些不注意的小毛病，包括系统的各个软件的配置文件可能有改动，加上常年累计尝试并添加很多 ppa&lt;/p&gt;

&lt;p&gt;的源，自定义的软件源在升级兼容的考虑下全部金禁用了导致原本软件源的注解名称也没有了，自己不知道各个软件源是干什么的&amp;hellip;于是手动在软件源管理（a本放在了 Applications -&amp;gt; Ubuntu Software Center 程序里面 Edit 菜单下面）清理。&lt;/p&gt;

&lt;p&gt;第一开始是凭记忆清理了一部分不再使用的软件的源，退出后更新发现失败&amp;hellip;再次清理 Authentication 里面的 Public key，发现还是有问题，最后下定狠心把所有的源和 public key 全部删除了再更新发现还是有错误 T_T 其实错误提示的是一种类型的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;W: GPG error: &lt;a href=&#34;http://ppa.launchpad.net&#34;&gt;http://ppa.launchpad.net&lt;/a&gt; jaunty Release: The following signatures couldn&amp;rsquo;t be verified because the public key is not available: NO_PUBKEY 12DE1BCB04E5E17B5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自己动手丰衣足食&amp;hellip;Google 之发现有两种解决方案，第一个是在 launchpad keyserver 网站搜索 key 从而找到 public
key，详情请看[这里][]。第二种则相对于比较简单：命令行流。&lt;/p&gt;

&lt;p&gt;​1. 复制报错的尾部 NO_PUBKEY 后面的串的后 8
位（以上面的为例：4E5E17B5），执行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpg --keyserver keyserver.ubuntu.com --recv 4E5E17B5# 返回信息gpg: requesting key 4E5E17B5 from hkp server keyserver.ubuntu.comgpg: key 4E5E17B5: public key &amp;quot;Launchpad PPA for chromium-daily&amp;quot; importedgpg: no ultimately trusted keys foundgpg: Total number processed: 1gpg:               imported: 1  (RSA: 1)
$ gpg --export --armor 4E5E17B5 | sudo apt-key add -# 返回信息OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何使用VirtualBox安装Linux系统</title>
      <link>/localhost/2008/03/how-to-use-linux-systems-installed-virtualbox</link>
      <pubDate>Thu, 13 Mar 2008 12:34:56 +0800</pubDate>
      
      <guid>/localhost/2008/03/how-to-use-linux-systems-installed-virtualbox</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.icyleaf.cn/2008/03/12/virtualbox-free-cross-platform-open-source-virtual-machine/&#34;&gt;VirtualBox&lt;/a&gt;也已经介绍过了，昨天是实实在在的用VirtualBox体验了一下 &lt;a href=&#34;http://www.linuxmint.com/&#34;&gt;Linux Mint&lt;/a&gt; 系统。这篇日志我就大概的说下如何用VirtualBox安装和汉化Linux Mint系统，大家先看一个经过简单设置有的效果图：&lt;/p&gt;

&lt;p&gt;这个背景是系统自带的一个，呵呵(\^___\^)，在介绍 &lt;a href=&#34;http://www.icyleaf.cn/2008/03/12/virtualbox-free-cross-platform-open-source-virtual-machine/&#34;&gt;VirtualBox&lt;/a&gt;
的文章里面的截图是系统默认的背景。那么如何使用 VirtualBox 安装 Linux
系统呢，其实很简单的，VirtualBox
这个软件从官方网站下载的时候看似是英文的，其实他支持多国语言，安装之后它就会因系统的语言而变化，Linux
Mint系统就从官方上面下载最新版本的镜像文件就可以了，当前最新版本是4.0。
这里我就不复述下载的过程~~&lt;/p&gt;

&lt;p&gt;两者都下载并安装VirtualBox之后，打开它的界面，点菜单的“新建”，安装向导的指示下一步有序操作：先点“下一步”，在随后出来的窗口的名称填入你喜欢的名字，如Linux
Mint或者其他以便自己识别，在系统类型里面他并没有列出具体的Linux的发行版号，只能靠内核的版本确定，这里LinuxMint的内核是Linux2.6。接着是配置虚拟内存，如果你机器的实际内存比较大如1G以上，可以配置虚拟内存到400M-512M。再下一步是设置虚拟硬盘，第一次使用是没有硬盘存在，需要”新建&amp;rdquo;，如果你不是第一次添加，则通过它的下拉菜单可选是那块虚拟硬盘。如果你是初级用户，在新建硬盘的时候，选择“动态扩展硬盘”即可，现在就完成了运行前的操作。&lt;/p&gt;

&lt;p&gt;之后直接点击菜单的“启动”就可以了，恩，没错直接启动就可以。VirtualBox提供了一个人性化的设置，如果你使用的是一个新建的虚拟硬盘，在它首次允许之后会弹出一个“首次运行向导”让你选择引导方式。恩，这和VM有些差别，VM提供一个虚拟的BIOS程序，而VrtualBox没有，不过他提供了一个开机引导方式的快捷键&lt;strong&gt;F12&lt;/strong&gt;，而且也支持LAN的方式，这点很强。&lt;/p&gt;

&lt;p&gt;在“首次允许向导”的戒指位置选择上图的操作，并在下拉菜单选择今天我们要按照的LinuxMint硬盘就可以了。
从下图可以看出来，虽然LinuxMint系统是基于Ubuntu系统开发的，但是它默认并不支持多国语言，仅仅只有英语：&lt;/p&gt;

&lt;p&gt;我们选择“Start Linux
Mint&amp;rdquo;启动系统，这就是像LiveCD版的了，随后会进行系统加载并进入到界面，点击桌面的”Install“会出现一个和Ubuntu以及gOS一样的安装系统的窗体，如果你安装过gOS，也许你会在网上搜如何汉化，他们的汉化方式有些变态，其实也是正确的，在选择系统语言环境的时候在选择框的倒数第二个是简体中文，但是如果你选择了，整个的界面全部会变成乱码。这样不利于我们的操作，所以我采取使用默认的英文，在安装好系统之后再进行汉化，相比之下，英文肯定比看乱码舒服多了。呵呵(\^___\^)&lt;/p&gt;

&lt;p&gt;Linux Mint安装就很简单了，我就不用说了吧，网上搜搜Ubuntu是如何安装的就知道了～嘿嘿，我就不多打字了～记得找LiveCD的安装教程，Ubuntu还提供了一个文本安装的方式：）&lt;/p&gt;

&lt;p&gt;安装完成之后，在登录界面输入完成你在安装时设置的用户名和密码随后会弹出一个询问向导。主要是为了提示是否开启Root并设置密码以及设置终端在打开时是否随机显示一段英文短句（我没自己看写的是什么），对于root一定要开启并设置一个密码，因为Linux的安全机制问题，尤其涉及到后面的安装软件问题，非常重要哦！&lt;/p&gt;

&lt;p&gt;登录界面之后，首先是要解决中文化的问题，首先确保你的机器已经连接到了互联网上面。连上网之后再进行操作：点击左下角的Mint图标，其实和Windows系统差不多，选择里面的”Control
Center“，在弹出的窗口寻找”Language Support“。随后Language
Support窗口会扫描当然的语言文件，已经提示是否下载，我们选择”Let me
later&amp;rdquo;，然后再Supported
Language列表中寻找Chinese，并在它后面的方框点击选中，然后再点Apply（应用），程序会从网上下载系统的程序的中文语言文件。这个时候我们就等待吧，如果网速好的话差不多，一杯咖啡的时间：）&lt;/p&gt;

&lt;p&gt;下载完成之后，点击“OK”并关闭Linux
Mint系统，其实是要重启，为什么要先关闭呢，因为现在还是开机光盘引导，当然我们要去掉光盘引导。先选择你要启动的系统，然后点击菜单的“设置”，在左侧的列表选择“光驱&amp;rdquo;之后去掉右边的”加载光驱“，然后再保存。之后就可以启动系统了，启动到grub菜单，选择第一个正常启动。第二个是安全模式，不过我没进去过&amp;hellip;菜单选择时间默认是4秒。&lt;/p&gt;

&lt;p&gt;又到了登录界面，我们先不急于登录，而是选择登录界面的&amp;rdquo;Language&amp;rdquo;，在选择语言窗口选择”Chinese（China
Mainland）“，在点”Change
Language“。系统立即弹出一个窗口，询问是否在以后登录也使用改变后的语言，我们当然是选择是了，之后我们看到我们熟悉的中国字了！尽情享受吧。&lt;/p&gt;

&lt;p&gt;不过他的中文化也不是非常的完美的，不过还有些地方并没有得到汉化，对于日常的使用并没有什么影响的。昨天我在Linux
Mint下面安装了不少的东西：SciTE，komodo
edit，甚至VirtualBox，本来想在Linux下虚拟一个XP，无奈的是不想再下一个600多M的镜像了&amp;hellip;不过我还是特别想看到XP虚拟跑Linux,再在虚拟的Linux在虚拟XP，这个场面肯定很壮观，哈哈
o(∩_∩)o&amp;hellip;&lt;/p&gt;

&lt;p&gt;同时也希望我这简单的教程对大家会有所帮助：）&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>