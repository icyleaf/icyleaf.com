<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Docker on icyleaf</title><link>https://icyleaf.com/tags/docker/</link><description>Recent content in Docker on icyleaf</description><language>zh-cn</language><lastBuildDate>Fri, 16 Sep 2022 13:58:31 +0800</lastBuildDate><atom:link href="https://icyleaf.com/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Rails 产品环境配置加密凭证的完美方案</title><link>https://icyleaf.com/2022/09/perfect-solution-to-steup-rails-encrypted-credentials/</link><pubDate>Fri, 16 Sep 2022 13:58:31 +0800</pubDate><guid>https://icyleaf.com/2022/09/perfect-solution-to-steup-rails-encrypted-credentials/</guid><description>面向用户的项目如何保证数据安全的情况下给用户提供一个便捷部署方式</description><content:encoded><![CDATA[<p>续接上文，项目已经构建镜像后下一步大概率就要开始面向受众人群去传播使用。你有想过让用户自建服务时他要踩的坑吗？那绝对就是加密凭证的配置。</p>
<h2 id="rails-教你这么做">Rails 教你这么做</h2>
<p>很遗憾除了 Rails 寥寥几笔的配置以外你几乎找不到任何不一样的文章。加密凭证的文件结构如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">├── config
</span></span><span class="line"><span class="ln">2</span><span class="cl">│  ├── master.key           <span class="c1"># 核心私钥</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">│  ├── credentials.yml.enc  <span class="c1"># 加密凭证</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">│  └── ...
</span></span></code></pre></div><p><code>master.key</code> 是某种算法随机生成的加密串，<code>credentials.yml.enc</code> 是存储了各种 key、token、secret value 的 YAML 数据加密后的凭证数据。</p>
<p>Rails 以安全为由（我猜的）对开发者也“封闭”了加密过程，只能通过 <code>rails credentials:edit</code> 命令解密 YAML 数据才能编辑和保存。最致命的该命令是使用 <code>EDITOR</code> 环境变量配置的文本编辑器，这个通常是 vim, nano 等终端文本编辑器。</p>
<p>这就需要在部署项目的时候无法一键部署，必须在部署前让使用者敲一堆的命令、还要在终端的文本编辑器再敲一堆需要配置的数据。</p>
<p>我想不仅使用者会疯掉，很多 Rails 开发者或许也会发怵。</p>
<h2 id="我的最佳实践">我的最佳实践</h2>
<blockquote>
<p>截止 2022-10-20 为止适用于 Rails 7.x 版本。</p>
</blockquote>
<p>上面提到的“封闭”的意思是使用者不可见加解密过程，但可通过<a href="https://github.com/rails/rails/blob/7-0-stable/railties/lib/rails/commands/credentials/credentials_command.rb">开源代码</a>一探究竟。</p>
<p>我的思路很简单，不提前生成和挂载上面两个文件，通过设置 <code>RAILS_MASTER_KEY</code> 和 <code>RAILS_ENCRYPTED_CREDENTIALS</code> 两个环境变量再变相实现。</p>
<ul>
<li>
<p><code>RAILS_MASTER_KEY</code> 是 Rails 内置的变量，它会<a href="https://github.com/rails/rails/blob/7-0-stable/activesupport/lib/active_support/encrypted_file.rb#L53">优先读取</a>最后才会读取 <code>config/master.key</code>。</p>
</li>
<li>
<p><code>RAILS_ENCRYPTED_CREDENTIALS</code> 环境变量保存 <code>credentials.yml.enc</code> 文件的加密凭证数据，项目启动阶段通过脚本预处理。</p>
</li>
</ul>
<h3 id="加密凭证生成器">加密凭证生成器</h3>
<p>面向用户自动化配置，这就意味着需要项目开发者提供傻瓜式的配置工具。</p>













  
  
    
      <figure data-pswp="2278x1206" data-size="800x"><a href="/uploads/2022/09/16/generate-encrypted-credentials-tools.png" class="gallery-item" target="_blank" data-pswp-width="2278" data-pswp-height="1206"><img src="/uploads/2022/09/16/generate-encrypted-credentials-tools_hu53cdae0c645814fab78a15ed8fe0af52_167183_800x0_resize_box_3.png"/></a><figcaption>

    <p>加密凭证生成器</p></figcaption></figure>

<p>上面是一个实现功能的基础版本，如果部署方式是 Docker 或 docker-compose 也可以提供生成对应的部署脚本或文件。</p>
<h4 id="核心源码">核心源码</h4>
<p>生成规则均借鉴 Rails 内部 <code>ActiveSupport::EncryptedFile</code> 和 <code>ActiveSupport::EncryptedConfiguration</code> 逻辑，数据库加密参考 <a href="https://github.com/rails/rails/blob/7-0-stable/activerecord/lib/active_record/railties/databases.rake#L531">database.rake</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">def</span> <span class="nf">create</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="n">env_key</span> <span class="o">=</span> <span class="s2">&#34;TEMP_MASTER_KEY&#34;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="no">ENV</span><span class="o">[</span><span class="n">env_key</span><span class="o">]</span> <span class="o">=</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">EncryptedConfiguration</span><span class="o">.</span><span class="n">generate_key</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">generator</span> <span class="o">=</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">EncryptedConfiguration</span><span class="o">.</span><span class="n">new</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="ss">config_path</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="ss">key_path</span><span class="p">:</span> <span class="s2">&#34;&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="ss">env_key</span><span class="p">:</span> <span class="n">env_key</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="ss">raise_if_missing_key</span><span class="p">:</span> <span class="kp">false</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">  <span class="n">master_key</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">key</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="n">contents</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="s2">&#34;secret_key_base&#34;</span> <span class="o">=&gt;</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">alphanumeric</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="s2">&#34;active_record_encryption&#34;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">      <span class="s2">&#34;primary_key&#34;</span> <span class="o">=&gt;</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">alphanumeric</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">      <span class="s2">&#34;deterministic_key&#34;</span> <span class="o">=&gt;</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">alphanumeric</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">      <span class="s2">&#34;key_derivation_salt&#34;</span> <span class="o">=&gt;</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">alphanumeric</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="no">ENV</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">env_key</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="n">render</span> <span class="ss">json</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="ss">master_key</span><span class="p">:</span> <span class="n">master_key</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="ss">encrypted_credentials</span><span class="p">:</span> <span class="n">generator</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:encrypt</span><span class="p">,</span> <span class="no">YAML</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">contents</span><span class="p">)),</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="ss">contents</span><span class="p">:</span> <span class="n">contents</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="k">end</span>
</span></span></code></pre></div><h3 id="自动化处理脚本">自动化处理脚本</h3>
<p>环境变量配置的 <code>RAILS_ENCRYPTED_CREDENTIALS</code> 变量并不会被 Rails 识别，必须在依赖 Rails 相关服务运行前（包括 Sidekiq）把变量的值转换成对应的文件即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">namespace</span> <span class="ss">:app</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="n">task</span> <span class="ss">:credentials</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">master_key_path</span> <span class="o">=</span> <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">,</span> <span class="s1">&#39;credentials&#39;</span><span class="p">,</span> <span class="s1">&#39;production.key&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">encrypted_file_path</span> <span class="o">=</span> <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">,</span> <span class="s1">&#39;credentials&#39;</span><span class="p">,</span> <span class="s1">&#39;production.yml.enc&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">encrypted_credentials</span> <span class="o">=</span> <span class="no">ENV</span><span class="o">[</span><span class="s1">&#39;RAILS_ENCRYPTED_CREDENTIALS&#39;</span><span class="o">].</span><span class="n">presence</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="n">encrypted_credentials</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="no">File</span><span class="o">.</span><span class="n">exist?</span><span class="p">(</span><span class="n">encrypted_file_path</span><span class="p">)</span> <span class="o">||</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">encrypted_file_path</span><span class="p">)</span><span class="o">.</span><span class="n">empty?</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      <span class="nb">puts</span> <span class="s2">&#34;Write encrypted data into </span><span class="si">#{</span><span class="n">encrypted_file_path</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      <span class="no">File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">encrypted_file_path</span><span class="p">,</span> <span class="no">ENV</span><span class="o">[</span><span class="s1">&#39;RAILS_ENCRYPTED_CREDENTIALS&#39;</span><span class="o">]</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">encrypted</span> <span class="o">=</span> <span class="no">Rails</span><span class="o">.</span><span class="n">application</span><span class="o">.</span><span class="n">encrypted</span><span class="p">(</span><span class="n">encrypted_file_path</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="k">if</span> <span class="n">encrypted</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">nil?</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">      <span class="nb">fail</span> <span class="o">[</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="s2">&#34;Missing `RAILS_MASTER_KEY` enviroment value and not found file in </span><span class="si">#{</span><span class="n">master_key_path</span><span class="si">}</span><span class="s2">.&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="s2">&#34;Make sure generate one first and store it in a safe place.&#34;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">      <span class="o">].</span><span class="n">join</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">next</span> <span class="k">if</span> <span class="n">encrypted_credentials</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="k">begin</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">      <span class="n">data</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">empty?</span><span class="p">(</span><span class="n">encrypted_file_path</span><span class="p">)</span> <span class="p">?</span> <span class="p">{}</span> <span class="p">:</span> <span class="p">(</span><span class="no">YAML</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">encrypted</span><span class="o">.</span><span class="n">read</span><span class="p">)</span> <span class="o">||</span> <span class="p">{})</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">      <span class="nb">puts</span> <span class="s2">&#34;Preparing encrypted keys: secret_key_base, active_record_encryption ...&#34;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">      <span class="c1"># Priority: environment &gt; rails builtin &gt; credentials.yml.enc data</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">      <span class="n">data</span><span class="o">[</span><span class="s1">&#39;secret_key_base&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="no">ENV</span><span class="o">[</span><span class="s1">&#39;SECRET_TOKEN&#39;</span><span class="o">].</span><span class="n">presence</span> <span class="o">||</span> <span class="n">data</span><span class="o">[</span><span class="s1">&#39;secret_key_base&#39;</span><span class="o">]</span> <span class="o">||</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">alphanumeric</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">      <span class="c1"># Support encrypted_key in model</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">      <span class="n">data</span><span class="o">[</span><span class="s1">&#39;active_record_encryption&#39;</span><span class="o">]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="s1">&#39;primary_key&#39;</span> <span class="o">=&gt;</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">alphanumeric</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="s1">&#39;deterministic_key&#39;</span> <span class="o">=&gt;</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">alphanumeric</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="s1">&#39;key_derivation_salt&#39;</span> <span class="o">=&gt;</span> <span class="no">SecureRandom</span><span class="o">.</span><span class="n">alphanumeric</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl">      <span class="no">Rails</span><span class="o">.</span><span class="n">application</span><span class="o">.</span><span class="n">encrypted</span><span class="p">(</span><span class="n">encrypted_file_path</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="no">YAML</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="k">rescue</span> <span class="no">OpenSSL</span><span class="o">::</span><span class="no">Cipher</span><span class="o">::</span><span class="no">CipherError</span><span class="p">,</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">MessageEncryptor</span><span class="o">::</span><span class="no">InvalidMessage</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">      <span class="nb">puts</span> <span class="s2">&#34;Couldn&#39;t decrypt </span><span class="si">#{</span><span class="n">encrypted_file_path</span><span class="si">}</span><span class="s2">. Perhaps `RAILS_MASTER_KEY` enviroment value is incorrect?&#34;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="k">end</span>
</span></span></code></pre></div><h3 id="docker-配置">Docker 配置</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">docker run -d <span class="se">\
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="se"></span>  -e <span class="nv">RAILS_MASTER_KEY</span><span class="o">=</span><span class="s2">&#34;[master_key]&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="se"></span>  -e <span class="nv">RAILS_ENCRYPTED_CREDENTIALS</span><span class="o">=</span><span class="s2">&#34;[encrypted]&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="se"></span>  <span class="o">[</span>image_name<span class="o">]</span>
</span></span></code></pre></div><p>我的最佳实践并不代表是最完美的解决方案，最起码能够让用户避免碰触代码也能够很轻松的部署才是前提，不是吗？</p>
]]></content:encoded></item><item><title>Rails 构建镜像安全处理加密凭证</title><link>https://icyleaf.com/2022/09/rails-build-docker-image-handle-encrypted-credentials-securely/</link><pubDate>Thu, 15 Sep 2022 13:58:31 +0800</pubDate><guid>https://icyleaf.com/2022/09/rails-build-docker-image-handle-encrypted-credentials-securely/</guid><description>Docker 构建镜像该如何正确处理 master key 和 credentials.yml.enc</description><content:encoded><![CDATA[<p>最近在做一个小的 Side Project 作为公共服务首要是需要保证用户数据的绝对安全，这就需要对数据库数据做加密处理。</p>
<p>Rails <a href="https://qiita.com/NaokiIshimura/items/2a179f2ab910992c4d39">5.2</a> 开始支持 <code>credentials.yml.enc</code> 加密凭证，
<a href="https://blog.saeloun.com/2019/10/10/rails-6-adds-support-for-multi-environment-credentials.html">6.0</a> 支持多环境的 credentials 加密凭证，
<a href="https://blog.saeloun.com/2021/06/09/rails-7-add-encryption-to-active-record.html">7.0</a> 支持对 model 数据库表字段加密处理，但我从 5.1 支持 <code>secrets.yml</code> 开始就没使用过。
最近一周开发加摸索下来，总结一句话：<strong>一直加密一直爽，容器化奔赴火葬场。</strong></p>
<h2 id="机制原理">机制原理</h2>
<p>初始化一个 Rails 5.2+ 项目会在项目根目录 <code>config</code> 生成 <code>master.key</code> 和 <code>credentials.yml.enc</code> 两个文件，前者可以理解为核心密钥，后者是用核心密钥通过
<a href="https://github.com/rails/rails/blob/7-0-stable/activesupport/lib/active_support/encrypted_configuration.rb">ActiveSupport::EncryptedConfiguration</a> 加密类生成的加密后的数据文件。</p>
<p>只需要保证 <code>master.key</code> 不会泄露，通过 <code>rails credentials:edit</code> 配置服务所需的各自私密 token、secret key 之类也可以安全的提交到 Git 仓库中。</p>
<h3 id="存储路径">存储路径</h3>
<p>密钥和加密后的文件会存在如下目录：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1"># 缺省</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">config/master.key
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">config/credentials.yml.enc
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"># Rails 生产环境决定 (6.0 开始支持)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"># 如下分别对应 development 和 production 环境</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">config/credentials/development.key
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">config/credentials/development.yml.enc
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">config/credentials/production.key
</span></span><span class="line"><span class="ln">11</span><span class="cl">config/credentials/production.yml.enc
</span></span></code></pre></div><h3 id="触发机制">触发机制</h3>
<p>只要运行的代码会涉及 <code>config/environment.rb</code> 文件解密流程就会自动被触发，比如：</p>
<ul>
<li><code>rails server</code></li>
<li><code>rails console</code></li>
<li><code>Rakefile</code> 附加 <code>:environment</code> 参数的所有 tasks</li>
</ul>
<h3 id="常见加解密报错">常见加解密报错</h3>
<p>解密机制被触发的那一刻，它会从存储路径从缺省到当前生产环境去寻找对应的文件，master key 会优先读取 <code>RAILS_MASTER_KEY</code> 环境变量的值，没有才会去存储文件读取，都没有找到就报错 <code>MissingKeyError</code> 错误。</p>
<p>master key 在 Rails 5.2 ~ 7 版本密钥的长度必须符合 aes-128-gcm 也就是 32 字节，设置错误会得到 <code>InvalidKeyLengthError</code> 错误。</p>
<p><code>*.enc</code> 文件不存在会触发 <code>MissingContentError</code> 错误。</p>
<p>其他的错误还有可能是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1"># 通常是 credentials.yml.enc 文件缺失或未设置 secret_key_base (SECRET_KEY_BASE) 的值</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">ArgumentError: Missing <span class="sb">`</span>secret_key_base<span class="sb">`</span> <span class="k">for</span> <span class="s1">&#39;production&#39;</span> environment, <span class="nb">set</span> this string with <span class="sb">`</span>bin/rails credentials:edit<span class="sb">`</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"># master key 密钥不正确无法解密</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">Unable to load application: ActiveSupport::MessageEncryptor::InvalidMessage: ActiveSupport::MessageEncryptor::InvalidMessage
</span></span><span class="line"><span class="ln">6</span><span class="cl">
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"># 错误同上</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">OpenSSL::Cipher::CipherError
</span></span></code></pre></div><p>成就大体都列出来了，至于你能到哪步就看你的造化了（开玩笑）。</p>
<h2 id="数据库字段加密">数据库字段加密</h2>
<p>Rails 默认并不会对数据库字段加密，在 7.0 开始允许开发者定义加密字段也允许自定义加解密方法。这个不是本文的讨论范围不再展开。</p>
<p>初始化需要通过如下命令生成一个随机的 Keys：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ rails db:encryption:init
</span></span><span class="line"><span class="ln">2</span><span class="cl">Add this entry to the credentials of the target environment:
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl">active_record_encryption:
</span></span><span class="line"><span class="ln">5</span><span class="cl">  primary_key: KMw07GoiPScVwtmoNxlBv7YibFCnB4dU
</span></span><span class="line"><span class="ln">6</span><span class="cl">  deterministic_key: CTttlez04KZcy3MCMFtZ8FUEopSAmJOr
</span></span><span class="line"><span class="ln">7</span><span class="cl">  key_derivation_salt: FwUgrDWHX3wN7kKw5gYSsYEgzxRnYBWh
</span></span></code></pre></div><p>在通过 <code>rails credentials:edit</code> 把上端加密串加到 credentials 里面保存即可，<strong>不同的加密串是无法解密已经存在数据库中的数据的，切记！切记！切记！</strong>
否则你会再获得一个成就 <code>ActiveRecord::Encryption::Errors::Decryption</code> 报错。</p>
<h2 id="镜像构建处理">镜像构建处理</h2>
<blockquote>
<p>恭喜你，从现在开始你本应当直面恐惧，可惜你发现了我这篇文章缺少了点悲惨的经历。</p>
</blockquote>
<p>制作 Docker 镜像无论什么情况都要保证不会包含任何私密数据，Rails 绕不开的点主要是 <code>rails assets:complie</code>。
上面我也说了只要涉及 <code>:environment</code> 参数的所有 tasks 都会走解密流程，它也不例外。</p>
<p>构建方面我通过三种方式来解析如果从不安全到安全的构建过程：</p>
<h3 id="-最不安全的方式">🚫 最不安全的方式</h3>
<p>镜像构建允许设置 <a href="https://docs.docker.com/engine/reference/commandline/build/#set-build-time-variables---build-arg">build-arg</a> 传递：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">FROM</span><span class="s"> ruby:3.0.3</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="err"></span><span class="k">ARG</span> master_key<span class="err">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">RAILS_MASTER_KEY</span><span class="o">=</span><span class="nv">$master_key</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">RAILS_ENV</span><span class="o">=</span>production
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c"># 省略</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="err"></span><span class="k">RUN</span> bin/rails assets:complie<span class="err">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="err"></span><span class="c"># 或者</span><span class="err">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="err"></span><span class="k">RUN</span> <span class="nv">RAILS_MASTER_KEY</span><span class="o">=</span><span class="nv">$master_key</span> bin/rails assets:complie<span class="err">
</span></span></span></code></pre></div><p>执行构建命令 <code>docker build -t app --build-arg master_key=[32bits-length-key] .</code> 构建后虽然可以获得镜像，但构建时设置的值也被封装在了容器中，就算没有封装到容器中使用 <code>docker history</code> 也可以看到，因此这种方式是绝对不可取的。</p>
<h3 id="-改进版">⭕️ 改进版</h3>
<p>你可能会看到有些镜像的 Dockerfile 里面会包含多个 <code>FROM</code> 的<a href="https://docs.docker.com/develop/develop-images/multistage-build/">多阶段构建</a>。这个是为了利用隔离资源，重复利用缓存机制的方式使得最终的容器极可能的小和安全。我们可以利用它把私密数据隔离在前面的临时镜像中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">FROM</span><span class="s"> ruby:3.0.3 as builder</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="err"></span><span class="k">ARG</span> <span class="nv">workspace</span><span class="o">=</span>/app<span class="err">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="err"></span><span class="k">ARG</span> master_key<span class="err">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">RAILS_MASTER_KEY</span><span class="o">=</span><span class="nv">$master_key</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">RAILS_ENV</span><span class="o">=</span>production
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c"># 省略</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> $workspace</span><span class="err">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="err"></span><span class="k">RUN</span> bin/rails assets:complie<span class="err">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="err"></span><span class="c"># 省略</span><span class="err">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> ruby:3.0.3-slim</span><span class="err">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="err"></span><span class="c"># 省略</span><span class="err">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>builder <span class="nv">$workspace</span> <span class="nv">$workspace</span><span class="err">
</span></span></span></code></pre></div><p>镜像存在 <code>builder</code> 和一个缺省名字（通常是 <code>stage-N</code>, N 是数字从 1 开始）两个阶段，第一阶段是最不安全方式的实现方式，这里在最后一个阶段通过一个干净安全的镜像把上一个阶段的结果文件复制过来就达成了第一个阶段中私密数据泄露的问题。</p>
<p>这种方式也是当前大多数人会应用的方式，尤其利用 Github Action 的 <a href="https://docs.github.com/en/actions/security-guides/encrypted-secrets">Encrypted secrets</a> 功能从某种程度上杜绝了隐私数据的泄露。</p>
<h3 id="-加强版">✅ 加强版</h3>
<p><a href="https://docs.docker.com/develop/develop-images/build_enhancements/">Buildkit</a> 是 Docker 新一代镜像构建工具，启用可以通过配置环境变量 <code>DOCKER_BUILDKIT=1</code> 或在 Docker 配置文件的 features 字典增加 <code>&quot;buildkit&quot; : &quot;true&quot;</code>。</p>
<p>由于采用新的构建工具，额外还需要在 Dockerfile 头部显性声明新的语法：<code>syntax = docker/dockerfile:1.2</code> 配合
<a href="https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information">新的构建 secret </a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c"># syntax = docker/dockerfile:1.2</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> ruby:3.0.3</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="err"></span><span class="k">ARG</span> <span class="nv">workspace</span><span class="o">=</span>/app<span class="err">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> $workspace</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="err"></span><span class="c"># 省略</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="err"></span><span class="k">RUN</span> --mount<span class="o">=</span><span class="nv">type</span><span class="o">=</span>secret,id<span class="o">=</span>master_key,target<span class="o">=</span>config/master.key,required<span class="o">=</span><span class="nb">true</span> <span class="se">\
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="se"></span>    bin/rails assets:precompile<span class="err">
</span></span></span></code></pre></div><p>构建命令执行需要通过 <a href="https://docs.docker.com/build/buildx/install/">buildx</a> CLI 子命令来完成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker buildx build <span class="se">\
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="se"></span>  --secret <span class="nv">id</span><span class="o">=</span>master_key,src<span class="o">=</span>config/master.key <span class="se">\
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="se"></span>  -t app .
</span></span></code></pre></div><p>结合 <a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/reference.md#run---mounttypesecret">&ndash;mount-type=secret</a> 支持的参数:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>密钥的唯一 id，默认是 target 参数的值的文件名</td>
</tr>
<tr>
<td>target</td>
<td>镜像内挂载的路径，默认是 <code>/run/secrets/</code> + <code>id</code></td>
</tr>
<tr>
<td>required</td>
<td>设置 <code>true</code> 当密钥不存在时报错，默认是 <code>false</code></td>
</tr>
<tr>
<td>mode</td>
<td>挂载后的文件权限，默认是 <code>0400</code></td>
</tr>
<tr>
<td>uid</td>
<td>设置密钥文件的用户 ID，默认是 <code>0</code></td>
</tr>
<tr>
<td>gid</td>
<td>设置密钥文件的用户组 ID，默认是 <code>0</code></td>
</tr>
</tbody>
</table>
<p><code>id</code> 关联 CLI 传参和构建镜像中执行步骤，CLI 入参设置 secret 的输入文件，构建镜像则需要把 secret 导出到镜像中具体的路径，其实就是这么简单。极少数支持 Docker
部署的云服务，比如 <a href="https://render.com/docs/docker-secrets">Render</a> 支持这种方式。部署到云服务上还需要重新考量下。</p>
<h2 id="本篇小结">本篇小结</h2>
<p>折腾一圈终于获得了一个干净、安全的镜像，等到部署时又傻眼了。面向技术人员或公司的项目倒还好，初始化时通过命令一通操作配置完也不需要处理 master key 不匹配的情况。
无论使用上面改进版还是加强版都能过顺利跑起来。如果 Docker 镜像是要面向客户的话，怎么让他们初始化一个属于他们自己的 master key 和加密数据呢？开始挠头了吧。</p>
<p><del>未完待续&hellip;</del> <a href="https://icyleaf.com/2022/09/perfect-solution-to-steup-rails-encrypted-credentials/">翻看答案</a>。</p>
<h2 id="参考资源">参考资源</h2>
<ul>
<li><a href="https://techblog.lclco.com/entry/2021/07/27/110000">Railsのcredentials.yml.encとmaster keyをDockerで安全に扱う</a></li>
<li><a href="https://pythonspeed.com/articles/docker-build-secrets/">Don’t leak your Docker image’s build secrets</a></li>
</ul>
]]></content:encoded></item><item><title>如何搭建家用 homelab: 先导篇</title><link>https://icyleaf.com/2022/02/how-to-homelab-part-0/</link><pubDate>Sat, 12 Feb 2022 20:00:00 +0800</pubDate><guid>https://icyleaf.com/2022/02/how-to-homelab-part-0/</guid><description>搭建 homelab 之前都需要了解哪些背景</description><content:encoded><![CDATA[<h2 id="前言">前言</h2>
<p>这将会是一个持续系列的主题文章，你将会从最基础的家庭 homelab 搭建开始循序渐进到一些进阶的系统、网络、服务层面的学习。我尽可能以新人的角色描述简单易懂的语言，系列文章会涉及家庭网络、路由器、Linux、数据储存、NAS、服务化等等，如果你在过程中又遇到任何问题，欢迎给我留言。</p>













  
  
    
      <figure data-pswp="4644x3004" data-size="800x"><a href="/tutorials/how-to-homelab/part-0/homelab-diagram-v2.0.png" class="gallery-item" target="_blank" data-pswp-width="4644" data-pswp-height="3004"><img src="/tutorials/how-to-homelab/part-0/homelab-diagram-v2.0_hud6b13e642cdec1b76e4883675cc1f0da_933051_800x0_resize_box_3.png"
      alt="图片来源"/></a><figcaption><p class="source">图片来源<a href="https://twitter.com/icyleaf/status/1472036769742745603">@icyleaf@twitter.com</a>
    </p>

    <p>2021 年底 v2.0 镇楼用的网络拓扑图</p></figcaption></figure>

<h2 id="搭建-homelab-起因">搭建 homelab 起因</h2>
<blockquote>
<p>homelab: a laboratory of (usually slightly outdated) awesome in the domicile</p>
</blockquote>
<p>从语言直译来看可以说是家庭 homelab，把这个事情延展到网络及服务上面那就可以干很多有意思的事情，比如：</p>
<ul>
<li>NAS 存储：资源下载、存放任何的数据（照片、小姐姐、学习资料、代码等）</li>
<li>影视库：从最简单的网络共享文件夹到可以托管影视管理、播放、转码为一体的 Jellyfin、Plex 服务</li>
<li>网络管理：设备限流、流量审计、防火墙策略</li>
<li>应用开发：做一些 side projects 需要开发环境、缓存、数据存储等</li>
<li>DevOps：ansible、salt、k8s 来操作维护多个服务器、VM 或者是 lxc</li>
</ul>
<p>如果您恰好是一名软件应用开发者，homelab 是最佳的扩展你的技能的很好的实验田，学习网络拓扑、Linux 系统、安全管理等。
对于大部分人来说或许多多少少都会听说过 NAS 服务器，其实他也是 homelab 的实践应用之一。</p>
<p>不要被它的名字吓到，本质上它就是在一个操作系统上面跑一堆上面提到和没提到的服务而已。</p>
<h2 id="自建考虑的点">自建考虑的点</h2>
<p>无论上面提到的点有多么吸引你想要组件自己的家庭 homelab，您还要慎重考虑是否真的需要，毕竟真的整一套也会投入很大的精力和一些资金，千万不要没有需求创造需求。</p>
<blockquote>
<p>本系列的内容会优先考虑使用开源、免费的解决方案，如果真的无法满足会分享一些商业的解决方案。</p>
</blockquote>
<h2 id="商业成品方案">商业成品方案</h2>
<p>商业成品主要是售卖软件服务来提供类网络管理、数据存储等的解决方案，市面上主流的主要是：</p>
<ul>
<li><a href="https://www.synology.com/">群晖</a>: 搭配硬件售卖，各方面都非常令人满意的软件系统，对小白非常友好</li>
<li><a href="https://www.qnap.com/">威联通</a>: 搭配硬件售卖的软件，价格比群晖有优势，软件系统相对群晖要逊色不少</li>
<li><a href="https://unraid.net/">UnRaid</a>: 一款商业的 NAS 系统，但提供快速扩容、Docker 和 VM 管理</li>
<li><a href="https://store.ui.com/collections/unifi-network-unifi-os-consoles">UniFi OS</a>: 主要是 Dream Machine 搭载的系统，整体下来价格非常昂贵</li>
</ul>
<p>通常情况下商业成品是一站式的解决方案，采购的话费用也会比自建要投入更多的资金，这个就不再 homelab 的考虑范围，这里就一笔带过。</p>
<h2 id="开源免费方案">开源&amp;免费方案</h2>
<p>自建 homelab 必然会从硬件、软件下手，准备好了再决定网络拓扑结构。</p>
<h2 id="硬件筛选">硬件筛选</h2>
<p>国内和国外的硬件环境有非常大的不同，国内有很多的洋垃圾、魔改硬件的讨论，比如您可能听说过的 E3/E5 神教、垃圾佬之类的名词。
若你是这个领域的行家恭喜你会省不少钱；若你不是也不用沮丧踏踏实实的花钱买数据安全，切记也不要盲目入手垃圾佬的硬件，捡垃圾有风险，有些硬件会被超的很高这样的性价比也会很低而不值得入手。</p>
<p>最关键的几个部分：CPU、内存、主板、网络和硬盘。</p>
<ul>
<li>CPU 和内存很好理解，CPU 核心数量、内存容量越多越能造，如果对于影视播放有要求就需要 CPU 有好的核心支持。</li>
<li>主板对网口数量、扩展槽会有依赖，网口数量和硬盘数量支持不多就要靠扩展槽来凑。</li>
<li>网络状况至关重要，WiFi 6 传输速度还是不如千兆有线，评估下自己家里猫和路由器最低要求千兆网络，有线也尽量是 CAT5e/CAT6 规格</li>
<li>NAS 应用场景对硬盘容量和规格要求比较高，SSD 不是强需求，如果不差钱全上 SSD 也不是不行。</li>
</ul>
<p>这里每一个展开聊都是非常大的话题，我可能会整理一些外部资源供您去补充这方面的知识。市面上也有一些成品硬件的解决方案，您也可以考虑：</p>
<ul>
<li>英特尔 NUC：小巧的机型并不代表他的性能很弱，最新 12 代的 NUC 从各方面都是很好的选择</li>
<li>联想 ThinkCentre 系列：比 NUC 稍微大点，这个系列体系非常的庞大且悠久，也有不少价格合适的二手和改装件，但会折腾一些</li>
<li>惠普 MicroServer Gen 系列：Gen8/Gen10 都是目前主流的 homelab 解决方案，正统服务器规格和特性。（我有一台 Gen 8 正在服役）</li>
<li>各种开发板：比如树莓派从 3B 开始它也能做一些 homelab 的应用场景，国内外资料丰富，配件众多。唯一的缺点受新冠影响它的价格在国内居高不下，可以考虑一些其他成熟的开发板。</li>
<li>各种矿渣主机：区块链盛行的挖矿行业充斥着很多挖矿主机，比如星际蜗牛、绿盘、蜜獾超存等，有些硬件参数还不错到手之后需要调节或改下静音风扇就可用。</li>
</ul>
<p>最简单的版本就是可以找一个可以长期运行的不再使用的笔记本电脑、台式电脑就能起步（功耗太高的话就真的算了）</p>
<h2 id="软件部署方案">软件部署方案</h2>
<p>硬件准备完备之后，我们来考虑搭配哪种软件部署方案，通常会被划分为三大类：</p>
<ul>
<li>传统部署（Traditional Deployment）</li>
<li>虚拟化部署（Virutalization Deployment）</li>
<li>容器化部署（Containerd Deployment）</li>
</ul>













  
  
    
      <figure data-pswp="1800x650" data-size="800x"><a href="/tutorials/how-to-homelab/part-0/container-evolution.png" class="gallery-item" target="_blank" data-pswp-width="1800" data-pswp-height="650"><img src="/tutorials/how-to-homelab/part-0/container-evolution_hu14ca6c0f8a2e7d8ef8516841ce4ab16c_259692_800x0_resize_box_3.png"
      alt="图片来源"/></a><figcaption><p class="source">图片来源<a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/">Kubernetes 是什么？</a>
    </p>

    <p>部署方式的演变</p></figcaption></figure>

<p>通常在硬件性能还算不错情况下都不会采用传统部署的方案，单主机的优先级：容器化 &gt; 虚拟化 &gt; 传统部署，机器性能不错且有技术兴趣度的优先级：虚拟化 &gt; 容器化 &gt; 传统部署。</p>
<h3 id="传统部署">传统部署</h3>
<p>传统部署通常是在 Bare-metal 机器上面进行的，因此我把它俩划为等号，它使用硬件主机安装操作系统如 Window、macOS 和 *nix (Unix/Linux) 后直接安装和部署服务，听起来没什么特别的，
市面上也会有很多的运维工具用于解决安装系统、配置环境、后期维护、数据备份的工作，比如 Salt、Ansible、Puppet 等有一定的学习成本，没法做到开箱即用， 100% 发挥硬件机能也会是一个问题。</p>













  
  
    
      <figure data-pswp="1920x1080" data-size="800x"><a href="/tutorials/how-to-homelab/part-0/bare-metal.jpg" class="gallery-item" target="_blank" data-pswp-width="1920" data-pswp-height="1080"><img src="/tutorials/how-to-homelab/part-0/bare-metal_hu4b369ced3c986b922f395ae6ff16aca0_920504_800x0_resize_q75_box.jpg"
      alt="图片来源"/></a><figcaption><p class="source">图片来源<a href="https://thecloudgirl.dev/BareMetal.html">The Cloud Girl</a>
    </p>

    <p>Bare metal 方案</p></figcaption></figure>

<h3 id="虚拟化部署">虚拟化部署</h3>
<ul>
<li><a href="https://www.vmware.com/products/esxi-and-esx.html">ESXi</a>: VMware 公司开发的硬件虚拟化解决方案，界面简单易用，自身功能较强，付费使用</li>
<li><a href="https://www.proxmox.com">Proxomx</a>: 基于 Debian 开发企业级虚拟化系统，支持硬件直通，可扩展集群，上手难度略高，简称 PVE</li>
</ul>
<p>基于开源解决方案实在没有太多可选性，PVE 是市面上最成熟、社区活跃也很高的方案，
就算遇到奇奇怪怪的问题善用搜索引擎代替上都可以解决。</p>
<h3 id="容器化部署">容器化部署</h3>
<ul>
<li><a href="https://www.docker.com/">Docker</a>: 现代容器化的开山鼻祖，自己比较作引发了大叛逃就有了下面两个解决方案</li>
<li><a href="https://containerd.io/">Containerd</a>: 始于 Docker 母公司，壮大在 CNCF 基金会，提供 nerdctl 代替 docker CLI</li>
<li><a href="https://podman.io/">Podman</a>: Red Hat 公司领导的兼容 Docker 的解决方案</li>
</ul>
<p>一句话总结没看懂就用 docker 就行。</p>
<h2 id="基础系统">基础系统</h2>
<p>如果选择传统部署随便用一个你熟悉且满足你需求的操作系统即可</p>
<h2 id="应用服务">应用服务</h2>
<p>定好软硬件的基础后您需要面对非常庞大的应用服务来扩展和丰富 homelab</p>
<h3 id="初阶方案">初阶方案</h3>
<h4 id="软路由">软路由</h4>
<ul>
<li><a href="https://github.com/openwrt/openwrt">openwrt</a>: 国内最近今年非常主流的解决方案，国内有个 <a href="https://github.com/immortalwrt/immortalwrt">immortalwrt</a> 分支版本</li>
<li><a href="https://www.asuswrt-merlin.net/">梅林</a>: 华硕开源的路由器固件，同样国内有个 <a href="https://www.koolcenter.com/">koolcenter</a> 改版</li>
<li><a href="https://dd-wrt.com/">dd-wrt</a>: 在流行刷路由器初期的懵懂的固件，受限于硬件支持度和更新频率渐行渐远，当时支持多 wan 的 tomato</li>
</ul>
<h4 id="网关">网关</h4>
<ul>
<li><a href="https://www.nginx.com/">nginx</a>: 老牌传统网关，用于托管或反向代理网站服务</li>
<li><a href="https://caddyserver.com/">caddy v2</a>: 现代化设计的 HTTP/2 且支持 <a href="https://letsencrypt.org/">Let’s encrypt</a> 的网关</li>
</ul>
<h4 id="dns">DNS</h4>
<ul>
<li><a href="https://dnsmasq.org/">dnsmasq</a>: 一切的基础，用于配置 DNS 和 DHCP 服务</li>
<li><a href="https://pi-hole.net/">pi-hole</a>: 主打保护隐私和过滤广告的路由系统，常用海外用户</li>
<li><a href="https://adguard.com/zh_cn/adguard-home/overview.html">adguard home</a>: 专注保护隐私和过滤广告全网广告拦截的服务，提供用户友善的 UI 界面</li>
<li><a href="https://github.com/pymumu/smartdns">smartDNS</a>: 加速 DNS 解析分流的 DNS 服务</li>
<li><a href="https://github.com/IrineSistiana/mosdns">mosdns</a>: 集 smartDNS 和 adguard home 优点并存的 DNS 服务但配置麻烦</li>
</ul>
<h4 id="防火墙">防火墙</h4>
<ul>
<li><a href="https://www.netfilter.org/projects/iptables/index.html">iptables</a>: Linux 常见的内置防火墙</li>
<li><a href="https://www.netfilter.org/projects/nftables/index.html">nftables</a>: iptables 的官方增强版，未来的趋势都会慢慢迁移过来</li>
<li><a href="https://www.pfsense.org/">pfSense</a>: 国外普遍使用的一款开源防火墙</li>
</ul>
<h4 id="nas">NAS</h4>
<ul>
<li><a href="https://www.openmediavault.org/">OpenMediaValut</a>: 硬件依赖低门槛的综合性 NAS 系统</li>
</ul>
<h4 id="服务部署">服务部署</h4>
<ul>
<li><a href="https://www.portainer.io/">portainer</a>: 简单容易上手的容器化部署解决方案</li>
</ul>
<h4 id="影音">影音</h4>
<ul>
<li><a href="https://jellyfin.org/">Jellyfin</a>: 影视剧、电影等媒体播放服务，支持片源资料搜刮和看过数据同步服务</li>
</ul>
<h4 id="应用">应用</h4>
<ul>
<li><a href="https://bitwarden.com/">Bitwarden</a>: 开源且完全可代替 1 Password 的全平台密码生成管理服务，推荐使用开发者用 Rust 重写的 <a href="https://github.com/dani-garcia/vaultwarden">vaultwarden</a></li>
<li><a href="https://zoneminder.com/">ZoneMinder</a>: 开源多路摄像头&amp;录像管理服务</li>
</ul>
<p>更多的应用可以关注我的<a href="https://github.com/stars/icyleaf/lists/self-host-services">自建服务集合</a></p>
<h3 id="高级进阶">高级进阶</h3>
<p>下面介绍的也仅限于我个人能力范围内目前想到的点，能力有限也请手下留情。</p>
<h4 id="网关-1">网关</h4>
<ul>
<li><a href="https://traefik.io/traefik/">traefik</a>: 一款开源的反向代理与负载均衡综合性工具</li>
</ul>
<h4 id="nas-1">NAS</h4>
<ul>
<li><a href="https://www.truenas.com/">TrueNAS</a>: 国外做数据存储的首选，基于 ZFS 文件系统内存大小决定磁盘容量的上限，前身叫 FreeNAS</li>
</ul>
<h4 id="服务部署-1">服务部署</h4>
<ul>
<li><a href="https://kubernetes.io/">Kubernetes</a>: 现代容器化编排系统，所谓的云 YAML 工程师终极工具 😆</li>
</ul>
<h2 id="小结">小结</h2>
<p>homelab 玩法的可能性是无限的，不要把想象力局限在这几年国内流行的所谓 AIO Boom：
使用 pve 部署一切，更甚者用 openwrt + docker 部署各自服务出现问题先不说，
真遇到服务器宕机一波全带走。</p>
<p>另外不要太过于计较服务器的功耗情况，只要不是电耗子 35W 还是 65W 没省多少电费，
下面是一个正面例子，虽然用的是 X99-T8D + E5 2696V3*2 + 金河田 6100 双路电源
但开发者主要用于适合自己场景的使用，那就不是浪费。</p>













  
  
    
      <figure data-pswp="1186x1124" data-size="800x"><a href="/tutorials/how-to-homelab/part-0/twitter-yetone-numa-server.png" class="gallery-item" target="_blank" data-pswp-width="1186" data-pswp-height="1124"><img src="/tutorials/how-to-homelab/part-0/twitter-yetone-numa-server_hu2c6ccebbd6f151ecdcdde6085b274214_838983_800x0_resize_box_3.png"
      alt="图片来源"/></a><figcaption><p class="source">图片来源<a href="https://twitter.com/yetone/status/1540235004495921152">@yetone@twitter</a>
    </p>

    <p>NUMA DIY 服务器</p></figcaption></figure>

<p>下面这个图中的例子是一个反面教材，要么哗众取宠要么非蠢即坏。</p>













  
  
    
      <figure data-pswp="1192x1660" data-size="800x"><a href="/tutorials/how-to-homelab/part-0/twitter-taresky-tpw-100w-nas-server.png" class="gallery-item" target="_blank" data-pswp-width="1192" data-pswp-height="1660"><img src="/tutorials/how-to-homelab/part-0/twitter-taresky-tpw-100w-nas-server_hufb1cbf63551b7d415425d25bb5adf88a_890096_800x0_resize_box_3.png"
      alt="图片来源"/></a><figcaption><p class="source">图片来源<a href="https://twitter.com/taresky/status/1555752846334705666">@taresky@twitter</a>
    </p>

    <p>待机 100W 的 NAS 服务器</p></figcaption></figure>

<p>最后的忠告，国内各自信息咨询站的 OpenWrt，NAS 文章看看就行，别太认真。
有那时间不如多看看官方文档，官方社区讨论 :D</p>
]]></content:encoded></item><item><title>如何使用 Docker 管理 Jenkins</title><link>https://icyleaf.com/2018/04/how-to-manage-jenkins-with-docker/</link><pubDate>Wed, 18 Apr 2018 14:44:32 +0800</pubDate><guid>https://icyleaf.com/2018/04/how-to-manage-jenkins-with-docker/</guid><description>让人几多愁的 Jenkins 该如何管理才能省心</description><content:encoded><![CDATA[<p>官方的 <a href="https://hub.docker.com/_/jenkins">jenkins</a> 镜像已经不再维护管理而是由 Jenkins Community 进行更新，鉴于 Jenkins 的更新频率特别快社区版本会提供两个版本：</p>
<ul>
<li><code>lts</code> 长期稳定版本，但还是会有新版提醒</li>
<li><code>latest</code> 每周更新版本</li>
</ul>
<p>都是基于 alpine 系统封装因此镜像的体积会大大减小很多。如果你是内网使用可以不用在意更新问题长期使用一个版本也没太大问题。</p>
<h2 id="安装">安装</h2>
<p>创建镜像时需要注意几个地方：</p>
<ol>
<li>关联本地 volumes</li>
<li>设置时区（默认是 UTC 时间）</li>
<li>映射 50000 端口（这个是 master 和 slave 的通讯端口）和 8000 端口（Web）</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">docker run -d --restart<span class="o">=</span>always
</span></span><span class="line"><span class="ln">2</span><span class="cl">    -p 8000:8080 -p 50000:50000
</span></span><span class="line"><span class="ln">3</span><span class="cl">    -v /var/lib/docker/jenkins:/var/jenkins_home
</span></span><span class="line"><span class="ln">4</span><span class="cl">    -e <span class="nv">JAVA_OPTS</span><span class="o">=</span>-Duser.timezone<span class="o">=</span>Asia/Shanghai
</span></span><span class="line"><span class="ln">5</span><span class="cl">    jenkins/jenkins:lts
</span></span></code></pre></div><p>对于进行设置 JAVA 的参数可以参考：https://github.com/jenkinsci/docker/issues/45</p>
<h2 id="配置-jenkins-的插件源">配置 Jenkins 的插件源</h2>
<p>使用过它的人都知道管理和安装插件是一个奇慢无比的事情，虽然提供了代理服务器但我这还有一个更好的方案。</p>
<p>我在翻阅国内镜像源网站的时候发现清华大学开源软件镜像站其实提供了国内 Jenkins 插件的镜像源但一直很低调的没有公布，通过进入<code>管理插件 -&gt; 高级</code>页面拉到最底部有个升级站点的自定义框，填入</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json
</span></span></code></pre></div><p>安装插件的时候系统默认会测试网络就是 ping 下 Google 的网站，它会提示失败但不用担心它会继续尝试下载和安装插件。</p>
<h2 id="升级">升级</h2>
<p>此方法适用于所有的容器的升级步骤。</p>
<p>首先需要找到容器的名字，这里我想会有不少人会问为什么你在创建一个容器的时候不指定一个名字，
那是因为后面还需要创建一个新版本的容器而名字不能一样，因此我现在创建都让 docker 随机分配。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker ps
</span></span><span class="line"><span class="ln">2</span><span class="cl">CONTAINER ID  ...   NAMES
</span></span><span class="line"><span class="ln">3</span><span class="cl">8f48718fdd07  ...   naughty_pasteur
</span></span></code></pre></div><p>拿到之后先停止运行后，创建一个数据备份容器再进行拉取最新版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker stop naughty_pasteur
</span></span><span class="line"><span class="ln">2</span><span class="cl">$ docker docker create --volumes-from naughty_pasteur --name jenkins-data jenkins/jenkins:lts
</span></span></code></pre></div><p>拉取最新版本后恢复数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker pull jenkins/jenkins:lts
</span></span><span class="line"><span class="ln">2</span><span class="cl">$ docker run -d --restart<span class="o">=</span>always
</span></span><span class="line"><span class="ln">3</span><span class="cl">    --volumes-from jenkins-data
</span></span><span class="line"><span class="ln">4</span><span class="cl">    -p 8000:8080 -p 50000:50000
</span></span><span class="line"><span class="ln">5</span><span class="cl">    -v /var/lib/docker/jenkins:/var/jenkins_home
</span></span><span class="line"><span class="ln">6</span><span class="cl">    -e <span class="nv">JAVA_OPTS</span><span class="o">=</span>-Duser.timezone<span class="o">=</span>Asia/Shanghai
</span></span><span class="line"><span class="ln">7</span><span class="cl">    jenkins/jenkins:lts
</span></span></code></pre></div><p>确保通过 web 访问和 build 正常后删除老的和数据备份的容器</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker rm naughty_pasteur
</span></span><span class="line"><span class="ln">2</span><span class="cl">$ docker rm jenkins-data
</span></span></code></pre></div><h2 id="疑惑解答">疑惑解答</h2>
<h3 id="1-我忘记设置时区但我进实例修改了时区在-jenkins-里不生效">1. 我忘记设置时区但我进实例修改了时区在 Jenkins 里不生效</h3>
<p>在 Jenkins 的系统设置页面找到脚本命令行运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">System</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="err">&#39;</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">commons</span><span class="o">.</span><span class="na">jelly</span><span class="o">.</span><span class="na">tags</span><span class="o">.</span><span class="na">fmt</span><span class="o">.</span><span class="na">timeZone</span><span class="err">&#39;</span><span class="o">,</span> <span class="err">&#39;</span><span class="n">Asia</span><span class="o">/</span><span class="n">Shanghai</span><span class="err">&#39;</span><span class="o">)</span>
</span></span></code></pre></div><p>执行后即时生效无需重启，方法来自<a href="https://wiki.jenkins.io/display/JENKINS/Change+time+zone">官方文档</a></p>
<h2 id="官方文档">官方文档</h2>
<p><a href="https://github.com/jenkinsci/docker/blob/master/README.md">https://github.com/jenkinsci/docker/blob/master/README.md</a></p>
]]></content:encoded></item><item><title>Docker 摸爬滚打对抗 CentOS 6</title><link>https://icyleaf.com/2016/12/docker-with-centos/</link><pubDate>Fri, 30 Dec 2016 17:52:30 +0800</pubDate><guid>https://icyleaf.com/2016/12/docker-with-centos/</guid><description>能不用 CentOS 就别了吧，啊不行？那就点进来看看吧</description><content:encoded><![CDATA[



<div class="updated">
  <header class="updated-header">
    <h4 class="updated-title">更新</h4>
    
    <p class="updated-meta">Oct 9, 2018</p>
    
  </header>
  <article class="updated-body">
    国庆期间恰巧服务器硬盘故障且运维并没有做 raid 备份，给更换了一台新内部服务器，索性升级到了 CentOS 7，因此针对 CentOS 6 安装 Docker 的答疑不再更新。
  </article>
</div>


<h2 id="前言">前言</h2>
<p>前不久终于把我们移动团队内部服务器从 CentOS 5.x 升级到了 6.8。本来是拜托让升级至 7.0 版本起码能用上 docker 1.12 版本还是靠谱的事情。
事情往往难以预料的被告知其他团队在安装 7.0 之后造成内部服务器群的网卡失灵的诡异故障只能作罢，想想起码还有个早期 docker 版本可安装也就先这么着吧。</p>
<p>这个是在 <a href="http://icyleaf.com/2013/09/how-to-install-gitlab-on-centos/">如何在CentOS 上安装Gitlab</a> 之后有一个无奈的使用指南，
因为运维也有他的考虑方面，参见知乎讨论：<a href="https://www.zhihu.com/question/29191794">如何说服运维选择 Debian/Ubuntu 而不是 CentOS</a></p>
<h2 id="安装-docker">安装 Docker</h2>
<h3 id="171">1.7.1</h3>
<p>Docker 最后一个支持 CentOS 6 的版本是 1.7.1 还必须安装 epel 源之后就<a href="https://github.com/docker/docker/issues/14365">被大家欢天喜地的抛弃了 6 的支持</a>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">sudo rpm -ivh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
</span></span><span class="line"><span class="ln">2</span><span class="cl">sudo yum -y remove docker
</span></span><span class="line"><span class="ln">3</span><span class="cl">sudo yum install libselinux-python docker-io
</span></span></code></pre></div><blockquote>
<p>由于 yum 内 docker 已经被其他使用，不用安装错误了。</p>
</blockquote>
<h3 id="171-以上版本">1.7.1 以上版本</h3>
<p><strong>请果断放弃这种想法</strong>，虽然你可能在网上搜索有个别的文章说把内核升级到 3.10 后可以安装 docker 1.9 版本，经过我个人反复测试根本不可行！</p>
<p>当然如果你还是坚持想尝试，请参考如下链接：</p>
<ul>
<li><a href="http://www.pangxie.space/docker/364">http://www.pangxie.space/docker/364</a></li>
<li><a href="http://www.cnblogs.com/dongdongwq/p/5381752.html">http://www.cnblogs.com/dongdongwq/p/5381752.html</a></li>
<li><a href="http://0evin.com/2016/06/17/%5B%E5%8E%9F%E5%88%9B%5DCentOS6.5%E5%AE%89%E8%A3%85Docker1.11.X%E7%89%88%E6%9C%AC/">http://0evin.com/2016/06/17/%5B%E5%8E%9F%E5%88%9B%5DCentOS6.5%E5%AE%89%E8%A3%85Docker1.11.X%E7%89%88%E6%9C%AC/</a></li>
</ul>
<h2 id="配置-docker">配置 Docker</h2>
<p>安装成功后先不要配置开机自启动和启动服务，docker 的官方镜像在国内众所周知的慢的一塌糊涂，如果你是在国内服务器使用请参考如下配置。</p>
<p>我这里把我个人私藏已久的好用的镜像告诉大家，大家可不要以为我用的是阿里云或者 DaoCloud 这类有很多限制的玩意：</p>
<ul>
<li>中国科技大学镜像：https://docker.mirrors.ustc.edu.cn</li>
<li>网易蜂巢镜像：http://hub-mirror.c.163.com</li>
</ul>
<p>同样需要注意的是 1.7.1 版本的 docker 配置文件是在 <code>/etc/sysconfig/docker</code> 而不是网上和官方说的 <code>/etc/default/docker</code> 打开此文件在 other_args 配置对于的源即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1"># /etc/sysconfig/docker</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1">#</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"># Other arguments to pass to the docker daemon process</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"># These will be parsed by the sysv initscript and appended</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"># to the arguments list passed to docker -d</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1">#other_args=</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1">#other_args=&#34;--registry-mirror=http://hub-mirror.c.163.com&#34;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="nv">other_args</span><span class="o">=</span><span class="s2">&#34;--registry-mirror=https://docker.mirrors.ustc.edu.cn&#34;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="nv">DOCKER_CERT_PATH</span><span class="o">=</span>/etc/docker
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"># Resolves: rhbz#1176302 (docker issue #407)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="nv">DOCKER_NOWARN_KERNEL_VERSION</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"># Location used for temporary files, such as those created by</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"># # docker load and build operations. Default is /var/lib/docker/tmp</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"># # Can be overriden by setting the following environment variable.</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"># # DOCKER_TMPDIR=/var/tmp</span>
</span></span></code></pre></div><p>后面就没什么好说的了，启动服务和设置开机自启动就完事了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">sudo chkconfig docker on
</span></span><span class="line"><span class="ln">2</span><span class="cl">sudo service docker start
</span></span></code></pre></div><p>验证下启动的服务是否已经配置了国内镜像源</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ ps aux <span class="p">|</span> grep <span class="s2">&#34;docker -d&#34;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">root     <span class="m">16992</span>  0.1  0.1 <span class="m">1239860</span> <span class="m">32276</span> ?       Sl   Dec29   2:02 /usr/bin/docker -d --registry-mirror<span class="o">=</span>https://docker.mirrors.ustc.edu.cn
</span></span><span class="line"><span class="ln">4</span><span class="cl">root     <span class="m">26873</span>  0.0  0.0 <span class="m">103332</span>   <span class="m">876</span> pts/2    S+   18:16   0:00 grep docker -d
</span></span></code></pre></div><h2 id="疑难杂症">疑难杂症</h2>
<h4 id="1-使用国内镜像源-pull-镜像偶尔会失败反复几次就可以解决">1. 使用国内镜像源 pull 镜像偶尔会失败，反复几次就可以解决</h4>
<p>频次不高原因未知，因此还未重视。</p>
<h4 id="2-docker-web-管理工具">2. Docker Web 管理工具</h4>
<p>推荐使用 <a href="https://github.com/portainer/portainer">portainer</a> ，兼容 1.7 的部分功能可能会发生部分功能和参数无法显示但不影响使用。之前我有推荐 rancher（可参考前篇文章：<a href="http://icyleaf.com/2016/08/how-to-install-rancher-on-osx/">如何在 OS X 上安装 Rancher
</a>），但 rancher 官方要求 docker 最低版本是 1.9+。</p>
<h4 id="3-docker-进程挂了重启后无法恢复之前的-containers">3. Docker 进程挂了重启后无法恢复之前的 containers</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker start c39206003c7a
</span></span><span class="line"><span class="ln">2</span><span class="cl">Error: Cannot start container c39206003c7a: Error getting container c39206003c7ae8992a554a9ac2ea130327fc4af1b2c389656c34baf9a56c84b5 from driver devicemapper: Error mounting <span class="s1">&#39;/dev/mapper/docker-253:0-267081-c39206003c7ae8992a554a9ac2ea130327fc4af1b2c389656c34baf9a56c84b5&#39;</span> on <span class="s1">&#39;/var/lib/docker/devicemapper/mnt/c39206003c7ae8992a554a9ac2ea130327fc4af1b2c389656c34baf9a56c84b5&#39;</span>: device or resource busy
</span></span><span class="line"><span class="ln">3</span><span class="cl">2014/05/08 19:14:57 Error: failed to start one or more containers
</span></span></code></pre></div><p>这种一般是因为意外终止进程造成上次的 volume 没有正常 unmount，只需手动操作下即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">unmount /var/lib/docker/devicemapper/mnt/d640aea67108b04c6a5ba14645966b092db1f807f3e3f41dca7a1470f76b68fb
</span></span></code></pre></div><blockquote>
<p><code>d640aea67108b04c6a5ba14645966b092db1f807f3e3f41dca7a1470f76b68fb</code> 是根据不同 container 生成的，请根据实际情况复制和执行。</p>
</blockquote>
<p>这个真没办法，只能在 Dockerfile 或者进实例里面进行修改时区，这个我就不过多赘述了。</p>
<h4 id="4-升级运行的-container-版本">4. 升级运行的 container 版本</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker stop xxxx
</span></span><span class="line"><span class="ln">2</span><span class="cl">$ docker create --volumes-from &lt;container_name_of_original_server&gt; <span class="se">\ </span>--name xxx-data image/name:&lt;tag_of_previous_rancher_server&gt;
</span></span><span class="line"><span class="ln">3</span><span class="cl">$ docker pull image/name:latest
</span></span><span class="line"><span class="ln">4</span><span class="cl">$ docker run -d --volumes-from xxx-data --restart<span class="o">=</span>unless-stopped <span class="se">\ </span>-p 8080:8080 image/namel.:latest
</span></span></code></pre></div><h4 id="5-非-root-用户执行-docker">5. 非 root 用户执行 docker</h4>
<p>创建 docker 用户组并重启 docker 服务，之后把你想要的用户加到 docker 用户组即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ groupadd docker
</span></span><span class="line"><span class="ln">2</span><span class="cl">$ service docker restart
</span></span><span class="line"><span class="ln">3</span><span class="cl">$ usermod -a -G docker icyleaf
</span></span></code></pre></div><h4 id="6-宿主机-cst-时间会造成-docker-实例时间不准">6. 宿主机 CST 时间会造成 docker 实例时间不准</h4>
<p>这个真没办法，只能在 Dockerfile 或者进实例里面进行修改时区，这个我就不过多赘述了。</p>
]]></content:encoded></item><item><title>如何在 OS X 上安装 Rancher</title><link>https://icyleaf.com/2016/08/how-to-install-rancher-on-osx/</link><pubDate>Fri, 05 Aug 2016 17:21:08 +0800</pubDate><guid>https://icyleaf.com/2016/08/how-to-install-rancher-on-osx/</guid><description>Rancher 0.x 版本部署指南</description><content:encoded><![CDATA[



<div class="updated">
  <header class="updated-header">
    <h4 class="updated-title">更新</h4>
    
    <p class="updated-meta">Feb 22, 2022</p>
    
  </header>
  <article class="updated-body">
    以下内容写于 Rancker 0.x 版本，后续版本变更比较大本文不再有没有参考。
  </article>
</div>


<p>Rancher 是 Docker 编排解决方案的一种，好处在于可以做容器编排，网络，存储，负载均衡，还能够支持云服务器（比如 Amazon EC2/Azure/DigitalOcean）也能够兼容 Docker Swarm/Mesos/Kubernetes 等其他的解决方案。自它还没有发布 <a href="http://rancher.com/announcing-rancher-1-0-ga/">1.0</a> 版本之前也有持续的关注。它自身还有个 <a href="http://www.infoq.com/cn/news/2015/03/rancheros-docker-linux">RancherOS</a> 对于 CoreOS 也是一个不小的威胁。</p>
<p>由于它提供非常优化的后台管理界面，同时也提供 REST API，日常开发使用中异常的方便。如果非要说出一点不好的，那可能就是它对内存有点小要求：<strong>最小 1GB 内存</strong>，因此如果想放在自己 VPS 上的童鞋需要评估下了。</p>
<h2 id="mac-安装">Mac 安装</h2>
<p>这块也趁着 <a href="https://docs.docker.com/docker-for-mac/">Docker for Mac</a> 的好处，终于摆脱的 <code>docker-machine</code> 的折磨，不用在依赖 VirtualBox，也不在每次装载 machine 的变量和查找虚拟机的 IP。映射的端口端口都通过 <code>localhost</code> 访问。</p>
<p>Rancher 通过 Docker 来安装本来说是非常简单的，它分为服务端和客户端。本教程以 <a href="http://docs.rancher.com/rancher/latest/en/installing-rancher/installing-server/">Single Node</a> 来讲解，不考虑 <a href="http://docs.rancher.com/rancher/latest/en/installing-rancher/installing-server/multi-nodes/">Multi Node</a>。</p>
<p>这块网上一直没有太好的解决方案，我看很多国外给出的<a href="https://gist.github.com/axnux/09dc375d71398cbbee44ebd23ba35a08">解决方案</a>也比较麻烦，主要是由于 Docker for mac 使用的是 xhyve 作为轻量化的虚拟化方案，而 rancher 安装 server 端没有任何问题，在添加主机的时候需要通过 HTTP 来连接 server 端而失败。下面我来带大家用最简单的方案来拆解。无需任何第三方的辅助。</p>
<h3 id="服务端">服务端</h3>
<blockquote>
<p>如果网速连接 docker hub 过慢可考虑使用代理设置或者国内的镜像服务，我这里分享一个 <code>https://docker.mirrors.ustc.edu.cn</code>，可在 Docker -&gt; Preferences&hellip; -&gt; Advanced -&gt; Registry Mirror 添加。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker run -d --name rancher-server --restart<span class="o">=</span>always -p 8080:8080 rancher/server
</span></span><span class="line"><span class="ln">2</span><span class="cl">$ docker logs -f rancher-server
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="nv">time</span><span class="o">=</span><span class="s2">&#34;2016-08-05T16:48:52Z&#34;</span> <span class="nv">level</span><span class="o">=</span>info <span class="nv">msg</span><span class="o">=</span><span class="s2">&#34;Creating schema machine, roles [service]&#34;</span> <span class="nv">id</span><span class="o">=</span>1ds17
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="nv">time</span><span class="o">=</span><span class="s2">&#34;2016-08-05T16:48:53Z&#34;</span> <span class="nv">level</span><span class="o">=</span>info <span class="nv">msg</span><span class="o">=</span><span class="s2">&#34;Creating schema machine, roles [project member owner]&#34;</span> <span class="nv">id</span><span class="o">=</span>1ds18
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="nv">time</span><span class="o">=</span><span class="s2">&#34;2016-08-05T16:48:53Z&#34;</span> <span class="nv">level</span><span class="o">=</span>info <span class="nv">msg</span><span class="o">=</span><span class="s2">&#34;Creating schema machine, roles [admin user readAdmin]&#34;</span> <span class="nv">id</span><span class="o">=</span>1ds19
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="nv">time</span><span class="o">=</span><span class="s2">&#34;2016-08-05T16:48:53Z&#34;</span> <span class="nv">level</span><span class="o">=</span>info <span class="nv">msg</span><span class="o">=</span><span class="s2">&#34;Creating schema machine, roles [readonly]&#34;</span> <span class="nv">id</span><span class="o">=</span>1ds20
</span></span></code></pre></div><p>看到如上类似的日志说明服务已经初始化完毕，通过浏览器访问 <code>http://localhost:8080</code> 就可以看到后台管理界面。</p>
<h3 id="客户端">客户端</h3>
<p>先不着急继续页面操作，回到终端上执行如下命令获取 rancher-server 容器的 IP 地址备用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker inspect --format <span class="s1">&#39;{{ .NetworkSettings.IPAddress }}&#39;</span> rancher-server
</span></span><span class="line"><span class="ln">2</span><span class="cl">172.17.0.2
</span></span></code></pre></div><p>接着上面的步骤，在打开页面能看到 Add Host 按钮并点击对于弹出 “Host Registration URL” 选择 “Something else:” 在后面的输入框填入上面的 IP 和端口号 <code>http://172.17.0.2:8080</code> 并保存。</p>
<p>之后就是给你一个客户端（部署主机）的选项，由于我们只添加本机作为部署主机使用，因此这里选择 Custom，其他不用任何设置，直接滑倒最底部找到一个执行 docker 命令的区域：</p>
<p><img loading="lazy" src="http://ww2.sinaimg.cn/large/006tNbRwjw1f6jdkffiqhj31ee150k0c.jpg"
  
  
  alt="add rancher host"></img>
</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker run -d --privileged -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/rancher:/var/lib/rancher rancher/agent:v1.0.2 http://172.17.0.2:8080/v1/scripts/676576FFEC2212A68391:1470416400000:tfqxfdglHL6Qw8dpLVtbOesYY4
</span></span></code></pre></div><p>你会发现执行可能会报错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">docker: Error response from daemon: Mounts denied:
</span></span><span class="line"><span class="ln">2</span><span class="cl">The path /var/lib/rancher
</span></span><span class="line"><span class="ln">3</span><span class="cl">is not shared from OS X and is not known to Docker.
</span></span><span class="line"><span class="ln">4</span><span class="cl">You can configure shared paths from Docker -&gt; Preferences... -&gt; File Sharing.
</span></span><span class="line"><span class="ln">5</span><span class="cl">See https://docs.docker.com/docker-for-mac/osxfs/#namespaces <span class="k">for</span> more info.
</span></span></code></pre></div><p>目前有可能是一个 Docker 的 Bug，因为 <code>/var/lib/rancher</code> 是挂载到已经默认添加 <code>/private</code> 文件共享，但是它还是报错，如果你在 Docker 设置的 File Sharing 添加的话它也不会让你添加，因此我们需要做一点小修改：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="ln">1</span><span class="cl">$ docker run -d --privileged -v /var/run/docker.sock:/var/run/docker.sock -v <span class="si">${</span><span class="nv">HOME</span><span class="si">}</span>/docker/rancher/var/lib/rancher:/var/lib/rancher rancher/agent:v1.0.2 http://172.17.0.2:8080/v1/scripts/676576FFEC2212A68391:1470416400000:tfqxfdglHL6Qw8dpLVtbOesYY4
</span></span><span class="line"><span class="ln">2</span><span class="cl">5cf22a10cf28b4182b6e205fa631146e86d67c3c9d86901ff8cf7ab087319a29
</span></span></code></pre></div><p>最后点击页面的 Close 后会跳转到 Host 的列表，你就能惊喜的发现添加成功了！</p>
<p><img loading="lazy" src="http://ww2.sinaimg.cn/large/006tNbRwjw1f6jdidcojkj315y0m4dik.jpg"
  
  
  alt="rancher host"></img>
</p>
<h2 id="结尾">结尾</h2>
<p>本篇只先解决这一个问题，更多使用的资料请看<a href="http://rancher.hidocker.io/">Rancher 实战红宝书</a>。</p>
]]></content:encoded></item></channel></rss>